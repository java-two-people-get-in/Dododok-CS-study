# [Network] HTTP/HTTPS

## 1. HTTP 프로토콜

클라이언트의 pc와 웹 서버는 HTTP `프로토콜` 을 이용하여 통신한다.

<img width="741" alt="image" src="https://github.com/user-attachments/assets/1c5a691e-a008-4ac8-b4e6-adebdb7a038e">


그리고 이 과정에서 주고받는 것을 요청과 응답을 `HTTP Message`라고 한다.

> 사용자가 웹 페이지를 보기 위해, 서버에 HTTP 요청을 보낸다.
서버는 요청을 수신하고  HTTP응답을 클라이언트에 보낸다.
브라우저는 해당 응답의 내용을 이용하여 페이지를 보여준다.
> 

### HTTP Request Message 표준 정의

<img width="751" alt="image" src="https://github.com/user-attachments/assets/d62a8044-68d0-49be-9484-396efb80b6dc">


### HTTP Response Message 표준 정의

<img width="737" alt="image" src="https://github.com/user-attachments/assets/e0b5c1e6-16f3-4005-bbfc-8510b9b496c3">


## 2. HTTP 프로토콜의 특징

### 2.1. 무상태(stateless)

http프로토콜은 상태를 저장하지 않는다. 클라이언트가 같은 객체를 여러번 요청해도, 이전의 **상태**를 기억하지 못하기 때문에, 같은 응답을 여러번 보낸다. ****

> 만약 정보를 저장하고 싶다면, 응답 헤더에 `Set-cookie`를 추가하여 클라이언트에서 저장하게 한다. 
그리고 클라이언트에서 요청을 보낼 때 마다 요청 헤더에 전달받은 `cookie` 를 이용하여 클라이언트가 누구인지 식별하게 한다.
**→ 쿠키&세션 인증 방식**
> 

### 2.2. 무연결성(Connectionless)

클라이언트에서 서버에 요청을 보내면 서버는 응답 후 접속을 끊는다. 이를 방지하기위해 HTTP1.1에서 `Connection` 헤더에 `keep-alive`를 입력하면 연결이 끊기지 않는다.

→ **persistent connection**

## 3. Persistent vs non-persistent

7계층인 `HTTP`프로토콜은 전송 프로토콜로 `TCP` 를 사용한다.

1. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다.
2. 연결이 이루어지면, 브라우저와 서버 프로세스는 각각의 소켓 인터페이스를 통해 TCP로 접속한다.
3. 클라이언트는 `HTTP 요청 메시지`를 소켓 인터페이스로 보내고, 소켓 인터페이스로부터 `HTTP 응답 메시지`를 받는다.
    
    마찬가지로, HTTP 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.
    

HTTP는 TCP가 어떻게 손실 데이터를 복구하고, 올바른 순서로 데이터를 배열하는지 **전혀 걱정할 필요가 없어** 계층 구조의 장점이 드러난다.

클라이언트는 서버와 `TCP`통신을 할 때, `지속 연결`과 `비지속 연결`중 하나를 고를 수 있다.

### 3.1. 비지속 연결(non-persistant)

`비지속 연결`은, 하나의 파일을 응답받기 위해, 하나의 tcp연결만을 수행하는 것이다.

- HTTP헤더에 `Connection : close`를 이용하면 된다.

1개의 `html`파일과 10개의 이미지 파일을 전송한다고 가정하자.

1. HTTP 클라이언트가 HTTP의 기본 포트 번호인 80을 통해 서버로 TCP 연결을 시도한다. 이 TCP연결과 관련해서 클라이언트와 서버 각각의 소켓이 존재한다.

2. 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청 메세지를 보낸다.

3. HTTP 서버는 연결 소켓을 통해 요청 메세지를 받는다. 그리고 요청된 html를 꺼내 HTTP 응답 메세지에 캡슐화해 담는다. 포장이 끝난 응답 메세지를 소켓을 통해 클라이언트로 보낸다.

4. TCP 클라이언트가 응답 메세지를 올바르게 받았다면, HTTP 서버는 TCP에게 TCP 연결을 끊으라고 한다.

5. HTTP 클라이언트가 응답 메세지를 전달받으면, TCP 연결이 중단된다. 받은 캡슐화된 메세지 안에는 html라는 정보가 포함되어있다. 클라이언트는 html파일을 조사해 10개 이미지에 대한 참조를 찾는다.

6. 참조되는 각 이미지 파일에 대해 1~4를 반복한다.

→ 총 11번의 tcp연결이 필요하다.

`tcp`연결을 위해 **2RTT+@** 의 시간이 걸리는데, 위 방식대로라면 **22RTT + 11@**의 시간이 걸린다.  ****

<img width="742" alt="image" src="https://github.com/user-attachments/assets/e38bf1ee-ddee-4c98-acf7-f7aa0e96532f">


### 3.2. 지속 연결(persistent)

지속 연결은 하나의 TCP 연결에 여러 개의 요청과 응답을 전송할 수 있는 방식이다(기존은 1TCP = 1req, 1res). 이로 인해 동시에 여러 데이터를 다운로드할 때 성능이 향상된다. 또한 하나의 TCP 연결로 모든 데이터를 다운할 수 있으므로, 서버의 부하를 줄일 수 있어, 더 많은 클라이언트를 수용할 수 있다.

→ **2RTT + 11@**의 시간이 걸린다.

## 4. HTTP 1.1 vs HTTP 2 vs HTTP 3

### 4.1. HTTP 1.1

기존에 사용하던 `HTTP 1.1`버전의 경우, 지속 연결을 사용할 때 하나의 `TCP` 연결을 사용한다. 

따라서 HOL문제, TCP헤더 오버헤드와 같은 문제가 발생할 수 있다.

→ HTTP 1.1에서는, HOL문제를 해결하기 위해 여러개의 TCP연결을 병렬로 수행하였다. 그리고 각 TCP연결이 공정하게 대역폭을 나눠 가지도록 하는 것이 **TCP 혼잡 제어(Congestion Control)이다.**

### 4.2. HTTP 2

HTTP/2의 주요 목표는 하나의 TCP 연결상에서 멀티플렉싱 요청/응답 지연 시간을 줄이는 데 있으며,

요청 우선순위화, 서버 푸시, HTTP 헤더 필드의 효율적인 압축 기능 등을 제공한다.

### 4.3. HTTP 3

TCP가 아닌 QUIC프로토콜을 사용한다. 표준화 X

## 5. HTTPS

`HTTP` 프로토콜은 전송 과정에서 암호화가 없다. 따라서 중요한 정보를 주고받더라도 HTTP메세지를 까 보면 내용물을 모두 확인할 수 있다.

따라서 등장한 `HTTPS` 프로토콜은 `HTTP` 프로토콜 전송 과정에 **SSL/TLS 프로토콜을** 사용하여 암호화를 추가한 것이며, 443번 포트를 사용한다.

`HTTPS`는 암호화 과정에서 **대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용한다.** 

### 5.1. SSL/TLS

- SSL(Secure Sockets Layer)
    
    클라이언트와 서버간의 통신을 암호화하여 데이터의 기밀성과 무결성을 보호한다.
    
    **디지털 인증서**로 불리며, 브라우저와 서버의 암호화된 연결을 수립할 때 사용한다.
    
- TLS(Transport Layer Security)
    
    SSL에서 발전한 것이며, SSL로 통용된다.
    

### 5.2. CA(Certificate Authority)

위와 같은 SSL 방식을 적용하려면 인증서를 발급받아 서버에 적용시켜야 한다.

**인증서**는 사용자가 접속한 서버가 우리가 의도한 서버와 맞는지 보장하는 역할을 하며, 인증서를 발급받는 기관을 CA라고 부른다,

- CA는 **공개키와 공개DNS명(`www.naver.com`)**의 연결을 보장하는 기관이다.
- `naver.com`의 공개키가 A인지 알 수 있는 방법은 없다. 따라서 CA는 이 정보를 CA만의 암호화 키를 이용하여 특정 공개키가 특정 사이트의 공개키라는 것을 보장한다.

ex) `Lets encrypt`, `AWS Certificate manager`

### 5.3. 대칭키 암호화 방식

- 동일한 키로 암호화, 복호화가 가능하다.
- 대칭키는 매번 랜덤으로 생성되어 누출되어도 다음에 사용할 때는 다른 키가 사용되기 때문에 안전하다.
- 공개키보다 **빠르게** 통신할 수 있다.

### 5.4. 비대칭키(공개키) 암호화 방식

- A키로 암호화를 하면 B키로 복호화를 할 수 있다.
- B키로 암호화를 하면 A키로 복호화를 할 수 있다.
- 암호화를 할 때 공개키를 사용하고, 복호화를 할 때 개인키를 사용함.
- 둘 중 하나를 비공개키(Private Key) 혹은 개인키라 부르며, 이는 자신만 가지고 있고 공개되지 않는다.
- 나머지 하나를 공개키(Public Key)라고 부르며 타인에게 제공한다. 공개키는 유출이 되어도 비공개키를 모르면 복호화 할 수 없기 때문에 안전하다.

<img width="801" alt="image" src="https://github.com/user-attachments/assets/9019191c-e0d0-4c89-87bd-a4fc7c710bf6">


## 6. 실제 HTTPS 동작 과정

### 6.1. 간단  ver.

1. 서버와 클라이언트가 `HttpMessage`를 주고받을 때, **세션키(대칭키) 암호화 방식**을 사용한다.
2. 1번 과정을 위해, 서버와 클라이언트가 세션키(대칭키)를 전달하는 과정에서 **공개키 방식**이 사용된다.

### 6.2. 조금더자세한 ver.

(사전조건) 통신을 위한 **세션키(대칭키)**를 만들어야 한다. (아직 없으며, 통신을 시작할 때 만든다.)

(사전조건) 서버는 본인의 **공개/개인키**를 가지고 있다.

(사전조건) 클라이언트는 본인의 **공개/개인키**를 가지고 있다.

1. https 통신을 위해, 서버와 클라이언트는 둘 다 세션키(대칭키)를 가지고 있어야 한다. 
2. 클라이언트는 대칭키를 생성하여, 서버의 공개키로 암호화하여 전송한다.
3. 서버는 서버의 개인키로 복호화하여, 대칭키 정보를 알아낸다.

### 6.3. 상세 ver.
<img width="719" alt="image" src="https://github.com/user-attachments/assets/9e019f00-68e8-4a5b-93cd-2a932ef3d8af">


(사전조건) 사이트 = 웹서버, 클라이언트 = 사용자.

(사전조건) 신뢰할 수 있는 인증 기관(CA)에서 제공하는 **인증서**는 해당 사이트가 믿을 수 있다는 인증서를 만드는 주체이다.

1. 사이트(웹 서버)는 공개키와 개인키를 만든다.
그리고 신뢰할 수 있는 인증 기관(CA)에 **서버 정보와 서버 공개키**를 관리 해 달라고 부탁한다.
2. 인증기관은 사이트의 데이터를 검증하고, **인증기관의 개인키로 서버에서 제공한 정보(사이트 정보, 사이트 공개키)를 암호화**하여 인증서를 만든다.
→ 개인키로 암호화를 하는 이유는, 누구든지 공개키로 복호화 할 수 있지만 암호화주체(=CA)에서 만들었음을 인증하기 위해서이다. 즉 변조가 되지 않고 CA에서 인증했다는 안전한 인증서임을 보장한다.
3. 만든 인증서를 서버에 보낸다. 이제 서버는 CA에서 인증한 인증서를 가지게 되었다.
4. 브라우저는, 인증기관들의 리스트와 공개키를 미리 가지고 있다.

---

여기까지가, 클라이언트가 접속하기 전에 일어나는 과정이다.

이후 과정은 실제 사용자가 사이트에 정보(`index.html`)을 요청했을 때의 과정이다.

<img width="812" alt="image" src="https://github.com/user-attachments/assets/d4acf872-067c-404e-8e1a-79ebb6e920b4">


1. 클라이언트가 사이트에 접속한다. 그리리고 사이트는 적절한 파일(`index.html`)을 반환하려고 할 것이다.
2. 사이트는 이전에 발급받은 인증서를 클라이언트에게 전송한다.
3. 브라우저는 인증기관(CA)의 공개키를 이미 알고 있으므로, 인증서를 공개키로 해독한다.
이 결과로 사이트의 정보와 **사이트의 공개키**를 알 수 있다.
→ 사이트의 공개키를, CA를 통해 확증받음.
4. 사이트의 공개키를 알게 되었으므로, 서버와 통신을 할 때 사용할 **대칭키**를 만든다.
5. 해당 대칭키를 사이트의 공개키로 암호화하여 전달한다.
6. 사이트는 해당 암호화 정보를 사이트의 개인키로 해독하여 대칭키를 얻는다.

→ 이제 서버와 클라이언트는 대칭키를 이용하여 통신할 수 있게 되었다.
