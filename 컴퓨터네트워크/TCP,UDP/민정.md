# [컴퓨터네트워크] TCP/UDP

## 1. TCP란?
전송계층(Transport Layer)에서 사용되는 프로토콜이다.

신뢰성을 보장하는 연결형 서비스이다. 데이터를 안정적으로, 순서대로, 에러 없이 교환할 수 있게한다. 

## 1-1. TCP 동작 과정
- 소켓 생성 -> 송/수신 측 연결(3 Way Handshake) -> 데이터 송신/수신 -> 송/수신 측 연결 해제(4 Way Handshake)
### 1. 소켓 생성
클라이언트가 서버로 TCP 연결을 시도하기 위해서는 클라이언트 측에 TCP 소켓을 생성해야 한다. Client는 운영체제에 socket( ) 시스템 콜을 이용하여 소켓을 생성합니다.

소켓이란 Application Lyaer와 Transport Layer 사이에서 데이터를 전달하는 출입구 역할을 하는 인터페이스이다..

### 2. 송/수신 측 연결(3 Way Handshake)
![3-way-handshake](https://github.com/user-attachments/assets/e2e528ff-5e77-429c-b0fa-1d0760236389)
Step 1 : 클라이언트는 서버에 연결을 요청하는 SYN 패킷을 보낸 후 서버의 응답을 기다리며 SYN_SENT 상태를 유지하고, 서버는 클라이언트의 요청을 받기 전엔 Wait for Cleint 상태를 유지한다.

Step 2 : 서버는 클라이언트가 보낸 SYN 패킷을 받고 SYN_RECEIVED 상태가 되고 SYN+ACK(요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷) 를 보내 응답한다.

Step 3 : 서버의 응답을 받은 클라이언트는 다시 서버에 ACK 패킷으로 응답하고 이를 서버가 받은 후 부터 세션이 생성되어 (Established) 연결이 완료 된다.

! 3 way handshake 과정이 있기 때문에 데이터의 전달 순서를 보장할 수 있게된다.

### 3. 데이터 송신/수신
Step 1 : 클라이언트는 브라우저에서 받은 HTTP Request 메시지를 TCP 헤더에 넣어서 패킷으로 만든 후 서버에게 전달한다. 

Step 2 : 패킷을 전달받은 서버는 응답을 하기 위해서 데이터를 만들고 다시 패킷으로 만들어 클라이언트에게 전달한다. 

! 만약 클라이언트는 서버로부터 일정 시간 동안 응답이 오지 않으면(중간에 패킷이 소실되게 되면) Step1의 패킷을 다시 재전송해서 요청을 하게된다. 이랬는데도 응답이 오지 않으면 클라이언트에서는 데이터 송신작업을 강제로 종료하고 어플리케이션에 오류를 반환하게 된다. 

### 4. 송/수신 측 연결 해제(4 Way Handshake)
![4-way-handshake](https://github.com/user-attachments/assets/a7446c48-54b8-4560-a29e-963178a3a3dd)
Step 1 : 클라이언트는 연결을 종료하고자 서버에 FIN 플래그를 보내고 FIN_WAIT 상태에 들어간다.

Step 2 : 서버는 클라이언트로 부터 FIN 플래그를 받은 뒤 ACK 패킷을 보낸 후 데이터를 모두 보낼 때 까지 잠시 TIME_OUT 이 된다. 이 때 서버는 ClOSE_WAIT 상태이다.

Step 3 : 서버가 연결을 종료할 준비가 되면, 연결을 해제할 준비가 되었다는 FIN 플래그를 클라이언트에 전송하고, 서버는 LAST_ACK 상태가 된다.

Step 4 : 클라이언트는 서버에 ACK를 보내 응답하고 클라이언트의 상태는 FIN_WAIT 에서 TIME-WAIT 으로 변경된다. 클라이언트의 ACK 응답을 받은 서버는 연결을 해제한다.
이 때, 클라이언트는 ACK 플래그를 보낸 이후 일정 시간동안 기다리게 되는데, 아직 서버에서 받지 못한 데이터가 연결이 해제되어 유실되는 경우를 대비해 잉여 패킷을 기다리는 TIME_WAIT 상태를 일정 시간 유지하게 된다. 일정 시간을 유지한 후 클라이언트는 소켓을 말소하면서 연결을 해제한다.

## 1-3. TCP 특징
### 1. 흐름제어 : 전송되는 데이터의 양을 조절하는 것
송신측과 수신측의 데이터 처리 속도가 다를 수 있는데, 이 경우 오버플로우 문제가 발생할 수 있다.
이러한 문제를 줄이기 위해 윈도우 크기(자신이 처리할 수 있는 데이터의 양)로 송신측의 데이터 전송량을 조절한다.

- stop and wait : 상대방에게 데이터를 보낸 후 잘 받았다는 응답(ACK)이 올 때까지 기다리는 방식이다.
  
![흐름제어 - stop and wait](https://github.com/user-attachments/assets/8c6ed92f-72f6-4de0-b50d-55b0e8a85169)

- sliding window : 송신 측이 수신 측에서 받은 윈도우 크기를 참고해서 데이터의 흐름을 제어하는 방식이다. 통신 과정 중에 네트워크 혼잡등의 이유로 윈도우 크기가 유동적으로 설정된다. 

### 2. 오류제어 : 통신 중 오류가 발생하면 해당 데이터를 재전송하는 것
- Stop and Wait
- Go Back N : 연속으로 데이터를 보내다가 오류가 발생한 지점부터 재전송하는 방식이다.

![오류제어 - Go Back N](https://github.com/user-attachments/assets/1ec078db-7200-4ba0-98e7-0bf423c7a158)
- Selective Repeat : 오류가 발생한 데이터만 재전송하는 방식이다.

![image](https://github.com/user-attachments/assets/12abc110-656a-45da-80dc-f98cb64af766)

### 3. 혼잡제어 : 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 방지하고 제거하는 것
- AIMD (Additive Increase / Multiplicative Decrease)
  - 처음에 패킷을 하나씩 보내고 문제가 발생하지 않으면 윈도우 크기를 1씩 증가하는 방법이다.
  - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷 전송 속도를 절반으로 줄인다.
  - 네트워크에 늦게 들어온 호스트가 처음에는 불리하지만, 시간이 흐르면서 평형상태로 수렴한다.

- Slow Start (느린 시작)
  - AIMD와 같이 패킷을 하나씩 보내고 문제가 발생하지 않으면 각 ACK 패킷마다 윈도우 크기를 1씩 늘려준다. 즉, 한 주기가 지나면 윈도우 크기는 2배가 된다.
  - AIMD와 달리 전송 속도를 지수 함수 꼴로 증가시켜서 윈도우 크기를 더 빠르게 증가시킨다.
  - 혼잡이 감지되면 윈도우 크기를 1로 줄인다.
  - 처음에는 네트워크 수용량을 예상할 수 있는 정보가 없지만, 한 번 혼잡 현상이 발생한 후에는 네트워크의 수용량을 어느 정도 예상할 수 있다.
  - 그래서 혼잡 현상이 발생하는 윈도우 크기의 절반가지는 지수 함수 꼴로 윈도우 크기를 증가시키고 그 이후에는 완만하게 1씩 증가시킨다.

- Fast Retransmit (빠른 재전송)

- Fast Recovery (빠른 회복)


## 2. UDP란?
전송계층(Transport Layer)에서 사용되는 프로토콜이다.

비연결형 서비스이다. 데이터를 빠르게 전송할 수 있게하다.

## 2-1. UDP 동작 과정
- 소켓 생성 -> 데이터 송신/수신

### 1. 소켓 생성
- TCP와 동일

### 2. 데이터 송신/수신
Step 1 : 클라이언트는 브라우저에서 받은 HTTP Request 메시지를 UDP 헤더에 넣어서 패킷으로 만든 후후 서버에게 전달한다. 

Step 2 : 패킷을 전달받은 서버는 응답을 하기 위해서 데이터를 만들고 다시 패킷으로 만들어 클라이언트에게 전달한다. 

! 이때 패킷이 소실 되더라도 다음 데이터를 바로 전송한다. 

## TCP vs UDP
|프로토콜 종류|TCP|UDP|
|------|---|---|
|연결방식	|연결형 서비스	|비연결형 서비스 |
|신뢰성 |높다 |낮다 |
|속도 |느리다 |빠르다 |
|사용되는 곳 | HTTP, HTTPS, 이메일 | DNS, 동영상, 음성 데이터 |


UDP -> DNS, 동영상, 음성 데이
