# TCP와 UDP

## **전송 계층(Transport Layer)**

![image](https://github.com/user-attachments/assets/c55e724a-a8c7-4802-919f-d4d141773f9c)

- TCP와 UDP는 4계층인 **전송 계층(Transport Layer)**에서 동작하는 프로토콜이다. 전송 계층은 **프로세스 간(process-to-process)**의 전송 기술을 다루며, 이를 통해 전 세계에서 실행 중인 특정 프로그램을 유일하게 식별할 수 있다.
- 2계층에서는 노드, 3계층에서는 호스트(컴퓨터)를 구분한 것과 달리, 4계층에서는 호스트 내의 프로세스를 구별할 수 있다.
- 호스트 내에서도 다양한 프로세스가 동시에 실행 중일 수 있기 때문에, 프로세스를 고유하게 식별하기 위해 **포트(Port)** 번호를 사용한다.
- 사전에 약속된 특별한 번호들(Well-known)이 있으며, 예를 들어 HTTP는 80번, HTTPS는 443번 포트를 사용한다.
- IP 주소는 아파트 주소에, 포트 번호는 집 호수에 비유할 수 있으며, 이 둘을 합쳐 **소켓 주소(Socket Address)**라고 부른다.

## **연결 지향 방식과 비연결 방식**

- 프로세스를 식별할 수 있는 주소를 이용하면 프로세스 간 통신이 가능하다. 이 때 두 가지 방식, **연결 지향(Connection-Oriented) 방식**과 **비연결(Connectionless Protocol) 방식**을 통해 통신할 수 있다.
- 연결 지향 방식은 송신자와 수신자가 1:1로 연결 상태를 유지하면서 통신하는 것을 의미한다. 이 방식에서는 데이터를 보내기 전에 연결 설정(Connection Establish) 단계를, 보낸 후에는 연결 종료(Connection Close) 단계를 거쳐야 한다. 이러한 방식은 데이터를 교환하는 데 있어 안전하고 신뢰할 수 있는 환경을 제공하지만, 교환 전후로 과정이 복잡하다. 이 방식의 대표적인 예는 **TCP**이다.
- 반면, 비연결 방식은 송신자와 수신자가 연결 상태를 유지하지 않고 통신하는 것을 의미한다. 이는 송신자가 수신자의 수신 여부와 상관없이 일방적으로 데이터를 전송하는 방식이다. 송신자 입장에서는 간단한 방법이지만, 수신자 입장에서는 데이터의 정확성과 순서가 보장되지 않으며, 데이터가 도착하지 않을 수도 있다. 이 방식의 대표적인 예는 **UDP**이다.

## *헷갈리는 데이터 단위들 용어 설명

- **세그먼트(Segment)** : 데이터를 적절한 크기로 분할한 덩어리로, 4계층에서 만들어짐
- **패킷(Packet)** : 세그먼트를 목적지로 전달하기 위해 IP 주소를 포함한 헤더가 붙은 형태, 3계층에서 만들어짐
- **프레임(Frame)** : 패킷을 목적지로 전달하기 위해 MAC 주소를 포함한 헤더가 붙은 형태, 2계층에서 만들어짐

## UDP란?

![image](https://github.com/user-attachments/assets/babff3f9-b18a-408f-9580-679653e6ed81)

- UDP는 **사용자 데이터그램 프로토콜(User Datagram Protocol)**의 약자이다. 데이터그램은 사용자가 전달하고자 하는 데이터를 네트워크로 전송하기 위해, 통신 정보 등을 담은 헤더를 씌운 독립적인 **패킷(Packet)**을 의미한다.
- UDP 헤더에는 프로세스 간 통신을 위한 정보만 포함되어 있으며, 다른 추가 정보는 없다. 이는 IP 주소가 3계층에서 처리되기 때문에 UDP에서는 포트 번호만 다루기 때문이다.
- UDP에는 체크섬을 통한 오류 검출 기능이 있지만, 복잡한 데이터 검증에는 한계가 있어, 통신 중 발생할 수 있는 오류 처리 기능을 직접 구현해야 하는 어려움이 있다.
- 데이터그램이 독립적인 패킷으로 전송되고, 헤더에 순서 정보가 없기 때문에 수신 측에서 데이터를 순서대로 재조립해야 한다. 또한, 중간에 패킷이 손실되더라도 UDP 자체로는 이를 감지할 방법이 없다.
- 이러한 특징들은 UDP가 비연결 방식의 프로토콜이기 때문에 발생한다. 따라서 UDP는 실시간성이 중요하거나 데이터의 신뢰성이 굳이 보장되지 않아도 되는 곳에서 사용된다.

## UDP 동작과정

![image](https://github.com/user-attachments/assets/5f919c61-366d-467c-9fd9-3c2e6c76b98d)

- 헤더만큼이나 UDP의 동작 과정도 매우 간단하다. 각 프로세스는 시작 시 운영 체제로부터 포트 번호를 부여받는다.
- UDP는 프로세스를 식별하고 통신하기 위해 **버퍼 역할을 하는 두 개의 큐(Queue)**를 생성하여 연결한다. 이 큐는 **송신 큐(Outgoing Queue)**와 **수신 큐(Incoming Queue)**로 구분된다.
- 송신 큐는 프로세스가 데이터를 외부로 전송하기 위해 사용되며, 프로세스가 송신 큐에 데이터를 넣으면 UDP는 이를 읽어 헤더를 붙이고 3계층(IP)으로 전달한 후 큐에서 제거한다.
- 송신 큐에 데이터가 과도하게 쌓이면 오버플로가 발생할 수 있는데, 이를 방지하기 위해 운영 체제는 송신 큐의 상태를 관리하며, 필요 시 프로세스에게 송신을 일시적으로 중단하도록 알린다.
- 수신 큐는 3계층(IP)에서 받은 패킷을 처리한다. 수신된 패킷의 포트 번호를 확인하여 해당 포트 번호를 사용하는 프로세스가 있으면, 패킷의 헤더 정보를 제거한 후 데이터를 해당 프로세스로 전달한다.

## TCP란?

![image](https://github.com/user-attachments/assets/f595003a-f346-41c8-af58-2d6eed5219e0)


→ 신뢰성 유지를 위해 헤더가 훨씬 무거움

한편 TCP는 **전송 제어 프로토콜(Transmission Control Protocol)** 의 약자로, 연결 지향 방식임과 동시에 스트림 기반(Stream-Oriented) 방식으로도 불린다. 이는 TCP 통신이 마치 가상의 연결선을 이용해 두 컴퓨터가 *연속적으로* 데이터 교환이 가능하게 하는 것처럼 보이기 때문이다.

헤더의 사진에서 볼 수 있듯이, UDP에 비해 담긴 데이터의 양이 상당히 무거운 편에 속하는 것을 알 수 있다. 좀 더 자세히 살펴보면 헤더에는 목적지 정보를 포함해 **시퀀스 넘버**, **승인 넘버(Acknowledgement Number)**, **제어 필드(Control Fields)** 등 많은 데이터들이 담겨 있다.

## TCP 3가지 핵심 기능

### 핸드셰이크

TCP는 *연결 지향 방식* 이기 때문에 데이터 교환 전후로 연결 설정/해제 과정을 거치는데 이를 핸드셰이크(Handshake) 과정이라고 부름

![image](https://github.com/user-attachments/assets/63e843d3-9c8e-46c9-a595-4e3de3cf7dd5)

**연결 설정 단계**에서는 3단계로 핸드셰이크 과정을 진행한다.

### **신뢰성과 흐름 제어**

TCP는 데이터가 중간에 소실되거나 회선 교환에 실패했다 하더라도, 이를 알아차리고 복구하기 위해 다양한 해결책을 제시하는 것이 특징. TCP는 데이터를 교환함과 동시에 헤더에 기록된 정보를 이용해 데이터의 신뢰성 제어와 흐름 제어를 동시에 진행한다.

### **혼잡도 제어**

**TCP가 각 네트워크에 할당되는 리소스를 늘려나가는데, 이 과정에서 오류가 발생하면 리소스를 초기화하는 과정을 거치게 됨**으로써 가능

- **슬로우 스타트(Slow Start)}**
    
    데이터 전송에 성공하게 되면, 다음 시도는 리소스(CWND, 혼잡 윈도우)를 지수(Exponential) 스케일만큼 더 많이 사용하는 통신을 시도한다. 이 때, 실패하게 되면 1부터 다시 시작한다.
    
    **합 증가/곱 감소(AIMD, Additive Increase/Multiplicative Decrease)** 방식은 이름에서 볼 수 있듯이 증가할 때는 합으로, 감소할 때는 절반으로 감소하는 방식.
    
    → 한정된 네트워크 자원을 여러 프로세스에게 균등하게 나눠줄 수 있다는 장점이 있지만, 통신 실패가 지속적으로 발생하기 때문에 그래프가 톱니바퀴처럼 울퉁불퉁함
    
    그러다보니 실제로는 속도를 최대한 균등하게 유지하기 위해 앞서 말한 규칙들을 적당히 혼합해서 쓰게 됩니다. 대표적인 방법이 바로 **타호(Tahoe)** 와 **리노(Reno)** 방식. 하지만 이러한 혼잡도 제어에도 불구하고, 통신 실패를 막거나 속도를 균일하게 유지할 수는 없기 때문에 TCP는 태생적으로 속도의 한계를 가지고 있다고 볼 수 있다.
    

![image](https://github.com/user-attachments/assets/21fed713-224d-4789-bfec-53abe1f33801)

**빨간색은 AIMD, 초록색은 슬로우 스타트 방식*

## **UDP와 TCP의 차이점 비교**
![image](https://github.com/user-attachments/assets/75ba308a-abce-4a44-b2a8-7a31493ee1ba)
