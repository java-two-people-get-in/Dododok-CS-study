# IPv4/IPv6

## IP 주소란?

**IP는 Internet Protocol의 약자로 기기간 네트워크 통신을 할 때 쓰는 프로토콜을 의미**한다. IP에서 IP기기의 주소를 나타내는 것이 바로 IP주소이다. 우편배달로 예를 들면 IP주소는 배달 주소를 나타내게 된다. 데이터를 정확하게 송수신하기 위해서는 IP주소가 필요하다.

### IP Datagram Format

IP 데이터는 TCP 또는 UDP로부터 받은 데이터(payload)에 네트워크 계층에서 필요한 정보들이 header에 덧붙여진다.

![image](https://github.com/user-attachments/assets/a1bc70d9-ce99-4a30-954a-db6da00d9b36)

- VER

: IP 프로토콜 버전 번호  // 현재: ver4, 차세대: ver6

- HLEN

: 헤더 길이(4바이트로 끊어서 표현) 
// 예) 20 바이트 => 20 / 4 = 5

- Service Type

: 데이터 속성(특징)  // diffserv(0:5), ECN(6:7)

- Length(Total Length)

: 전체 데이터그램(헤더+데이터) 길이  // 예) 16비트 = 2^16 - 1

- Identifier & Flag + Fragment offset

: Fragment 시에 사용

- TTL(Time To Live):

최대로 거칠 수 있는 홉의 수(=생존 시간)

- Upper Layer Protocol:

상위 계층(트랜스포트 계층)에 어떤 프로토콜이 있는지  // UDP, TCP

- Header Checksum

: UDP의 체크섬과 동일

- 출발지 IP 주소
- 도착지 IP 주소
- Option: 선택 헤더 (0~40 바이트)

<br/>

### IP 단편화 및 재결합

네트워크 링크에는 MTU(Maxium Transmission Unit)이 있다. 즉, 데이터의 최대 크기가 존재하며 MTU 사이즈는 네트워크 링크 종류에 따라 다르다.

![image](https://github.com/user-attachments/assets/ada96923-3908-4443-9aae-73ba71e5bbaa)

- 단편화 (fragmentation)
: 만약, 큰 MTU 사이즈를 가진 네트워크에서 작은 MTU 사이즈를 가진 네트워크로 데이터를 이동시켜야 한다면 데이터를 잘게 쪼개야 한다.
- 재결합 (reassembly)
: IP header에는 쪼개진 datagram 조각의 순서를 식별하기 위한 필드가 포함되어있다. 쪼개진 datagram을 마지막 도착지에서 다시 합치는 것을 재결합(reassembly)라고 한다.

<br/>

## IPv4

![image](https://github.com/user-attachments/assets/e881c054-237b-48b8-8b80-241dbdca8a19)

**IPv4**는 32비트(bit)로 구성되어있으며, 한 칸당 10진수 8bit의 IP 주소로 구성되어있다. 각 마디는 **옥텟(octet)**이라고 부른다. 

ex) 192.168.123.123

- IP 주소는 호스트 또는 라우터의 네트워크 인터페이스마다 하나씩 존재한다. 하지만, 호스트 또는 라우터의 대부분은 두 개 이상의 네트워크 인터페이스가 존재하므로 IP 주소도 여러 개 존재할 수 있다.

<br/>

### 서브넷(subnets)

32비트의 IP 주소는 크게 두 부분으로 나뉜다.

1. **서브넷(subnet)**을 나타내는 부분 - 상위 bits
2. 네트워크 안에서의 **호스트(host)**를 나타내는 부분 - 하위 bits

- 여기서 서브넷(subnet)이란 IP 주소에서 동일한 장치의 인터페이스를 말하고 하나의 서브넷 안에서는 라우터 없이 연결되어있으므로 동일한 LAN(이더넷 or Wifi) 안에 존재해서 상호 간에 물리적으로 연결되어 있다. 그러므로 중계 라우터 없이도 서로 물리적으로 도달하는 것이 가능하다.
- 호스트(host)는 특정 서브넷 안에서의 구체적인 호스트의 번호를 나타낸다.

**서브넷 마스크(subnet mask)**
: 상위 몇 비트(bit)까지 서브넷을 사용할 것인가를 나타내며 슬래시(/)로 나타낸다.

ex) 223.1.3.0/24 라는 서브넷 마스크가 의미하는 것은 상위 24비트(3칸)까지 서브넷으로 사용함을 의미.

<br/>

### IPv4 클래스

| Class | 첫번째 옥텟 | 첫번째 옥텟의 값의 범위(10진수) | 이론적 IP주소 범위 |
| --- | --- | --- | --- |
| A class | 0xxx xxxx | 0 ~ 127 | 0.0.0.0 ~ 127.255.255.255 |
| B class | 10xx xxxx | 128 ~ 191 | 128.0.0.0 ~ 191.255.255.255 |
| C class | 110x xxxx | 192 ~ 223 | 192.0.0.0 ~ 223.255.255.255 |
| D class | 1110 xxxx | 224 ~ 239 | 224.0.0.0 ~ 239.255.255.255 |
| E class | 1111 xxxx | 240 ~ 255 | 240.0.0.0 ~ 255.255.255.255 |

IPv4는 한 옥탯당 256개의 수를 나타낼 수 있어서 256^4 = 4,294,967,296개, 약 43억개의 IP 주소를 만들 수 있다. 80년대에는 IP주소가 부족할 것이라고 상상도 하지 못했지만 인터넷 환경이 발달함에 따라 어마어마하게 많은 수의 IP주소가 필요해져 IPv4 주소 체계로는 IP주소를 할당하기가 어려워졌다. 따라서 새로운 주소 체계인 IPv6가 나오게 되었다.

**IP Class의 경우 A, B, C, D, E Class로 나누어 Network ID와 Host ID를 구분**하게 된다.

- **A Class**의 경우 처음 8bit(1byte)가 **Network ID**이며, 나머지 24bit(3byte)가 **Host ID**로 사용된다.
    
    비트가 0으로 시작하기에 네트워크 할당은 0~127이다 . 즉, 128 곳에 가능하며, 최대 호스트 수는 16,777,214개이다.
    
- **B Class**의 경우 처음 16bit(2byte)가 **Network ID**이며, 나머지 16bit(2byte)가 **Host ID**로 사용된다.
    
    비트가 10으로 시작하기에 네트워크 할당은 16,384 곳에 가능하며, 최대 호스트 수는 65,534개이다.
    
- **C Class**의 경우 처음 24bit(3byte)가 **Network ID**이며, 나머지 8bit(1byte)가 **Host ID**로 사용된다.
    
    비트가 110으로 시작하기에 네트워크 할당은 2,097,152 곳에 가능하며, 최대 호스트 수는 254개이다.
    
<br/>

### IPv6

IPv4는 32bit의 이진수로 이루어져있지만, **IPv6** 주소체계는 총 **128bit**로 각 16bit씩 8자리로 각 자리는 **:(콜론)**으로 구분한다.

![image](https://github.com/user-attachments/assets/e9d9b437-4945-49bc-a38f-9f6768428326)

→  IPv4의 32bit 길이의 IP 주소 공간(약 43억 개)는 이미 고갈된 상태이므로 128bit 길이의 IPv6가 등장! IPv6는 2^128개의 주소공간을 수용할 수 있으므로 주소 부족의 문제를 해결하였다.

### 특징 및 장점

- IP주소의 부족 현상을 해결하기 위한 차세대 IP주소체계
- IPv4의 주소 공간을 4배 확장한 것으로 128bit 체계의 16진수로 표기하며, 4개의 16진수를 콜론(:)으로 구분
- IPv4에서는 옵션 필드의 구성이 제한적인데 비해 IPv6에서는 확장헤더를 이용하여 IPv4보다 훨씬 다양하고 안정된 옵션을 사용할 수 있음
- 라우터의 부담을 줄이고, 네트워크 부하를 분산시킴
- 보안, 인증, 라벨링, 데이터 무결성, 데이터 비밀성 제공
- 특정 흐름의 패킷들을 인식하고, 확장된 헤더에 선택사항들을 기술할 수 있음
- IPv6 종류: 유니캐스트, 애니 캐스트, 멀티 캐스트

<br/>

### **IPv6 Datagram Format**

![image](https://github.com/user-attachments/assets/945dca76-1335-4199-87a5-92a2c3a210b8)

<br/>

## **IPv4와 IPv6의 주요 차이점**

**1. 보안강화**

- IPv6는 보안을 염두에 두고 구축되었기에 기밀성, 인증 및 데이터 무결성을 제공. IPv4 구성 요소인 인터넷 제어 메시지 프로토콜(ICMP)은 맬웨어를 전달할 가능성이 있으므로 회사 방화벽에서 이를 종종 차단한다. 반면 IPv6 ICMP 패킷은 IPSec를 사용해 훨씬 더 안전하고 손쉽게 이를 막을 수 있다.

**2. 지리적 제한 없음**

- IPv4 주소와 달리 IPv6 주소는 전 세계 어느 곳에서도 사용할 수 있다. IPv4 주소의 50%는 생성될 때 미국에서 사용하는 용도로 예약되었다.

**3. 보다 효율적인 라우팅**

- IPv4 헤더는 길이가 가변적이지만 IPv6에는 일관된 헤더가 있다. 즉, 이러한 주소로 라우팅하기 위한 코드가 더 간단해지고 하드웨어 처리도 덜 필요하다. 이는 결과적으로 IPv6는 더 나은 서비스 품질과 사용자 경험을 갖게 되는 것을 뜻한다.

**4. 끝과 끝 연결**

- 기술자들은 IP 주소 부족을 해결하기 위해 네트워크 주소 변환(NAT) 방법을 만들었다. 하지만 IPv6는 모든 장치에 대해 충분한 IP 주소를 생성하므로 NAT가 더 이상 필요하지 않게 되었다. 이제 각 장치가 인터넷에 연결되어 웹사이트와 직접 통신할 수 있게 되었다.

**5. 자동 구성**

- IPv6의 가장 좋은 기능 중 하나는 상태 비상태 유지 자동 저장 구성일 것이라고 한다. 이를 통해 장치는 서버 없이도 자체 IP주소를 할당할 수 있다. 대신 사용자가 소유한 모든 휴대폰, 태블릿 또는 노트북에 고유한 장치의 MAC 주소를 사용하여 IP주소가 생성된다. 이렇게 하면 동일한 네트워크에 연결된 장치가 서로를 더 쉽게 검색할 수 있다.

아직까지도 많은 라우터들은 IPv4를 사용한다. IPv6로의 전환은 많은 시간과 비용이 들기 때문에 완료되기까지 적지 않은 세월이 걸릴 것이다. 현재는 IPv4와 IPv6를 혼용해서 사용하는데, **IPv4 라우터에서는 tunneling이라는 방식을 사용해 IPv6 데이터그램을 전송한다.**

<br/>

### **IPv4에서 IPv6로 전환하는 방법**

![image](https://github.com/user-attachments/assets/f350d699-b6e5-4834-8727-454dc03eb080)

- **터널링(turnneling)**
현재 IPv4와 IPv6를 동시에 사용하고 있지만, 옛날의 기술은 최신 기수릐 존재를 모르듯이 IPv4는 IPv6의 존재를 알지 못하므로 IPv4는 IPv6의 기능을 지원할 수 없다. 이를 해결하기 위해 사용하는 기법으로, 터널링은 IPv4 라우터에서 IPv4의 datagram의 payload에 IPv6의 datagram을 넣어 전달함으로써 IPv6와의 호환성을 해결한다.
