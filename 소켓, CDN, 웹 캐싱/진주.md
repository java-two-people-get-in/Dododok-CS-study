# 소켓 / CDN / 웹 캐싱

# 소켓


## 소켓(Socket)이란?

소켓이란 두 프로그램이 네트워크를 통해 서로 통신할 수 있도록 양쪽에 생성되는 링크의 단자이다. 두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있다. 소켓의 구현을 통해 네트워크 및 전송 계층의 캡슐화가 가능하다. 기본적으로 소켓은 통신을 위한 통로로서 데이터를 보내거나 받는 역할을 하며, 연결을 수동적으로 기다리느냐, 능동적으로 연결하느냐에 따라 서버와 클라이언트로 구분할 수 있다.

소켓은 TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)로 나뉘며, 각각의 장단점에 따라 적절히 활용하는 것이 전체 성능에 큰 영향을 준다. TCP는 신뢰할 수 있는 통신을 제공하고, UDP는 몇 가지 신뢰도를 포기하고 더 직접적인 통신을 한다. 또한, 소켓 함수는 동기모드(블로킹)와 비동기모드(논블로킹)로 동작한다. 동기모드는 데이터를 수신할 때까지 대기하지만, 비동기모드는 데이터가 없을 경우 수신된 데이터가 없다는 정보만 리턴하고 넘어간다.

실제로 대기한다는 의미는 시스템을 멈추고 기다린다는 것이 아니라 다른 쓰레드나 프로세스로 실행 권한을 넘기는 것이다. 비동기 모드에서 풀링(polling)하면서 대기하는 것과는 달리, 프로세서를 효율적으로 활용할 수 있다. 소켓 통신을 처리하는 함수 외에도 select, epoll, IOCP 같은 함수들을 통해 여러 개의 소켓을 처리하는 멀티플렉스 처리를 고려할 필요가 있다.

<br><br>

## 소켓의 종류

### 1. 스트림 (TCP)

스트림 소켓은 양방향으로 바이트 스트림을 전송할 수 있는 연결 지향형 소켓으로, 양쪽 애플리케이션이 데이터를 주고받을 수 있다. 오류 수정, 전송 처리, 흐름 제어 등을 보장하며 송신된 순서에 따른 중복되지 않은 데이터를 수신한다. 연결을 맺는 과정에서 약간의 오버헤드가 있으므로 대량의 데이터를 보내는 경우에 적합하다. 스트림 소켓은 이러한 품질의 통신을 위해 TCP를 사용한다.

### 2. 데이터그램 (UDP)

데이터그램 소켓은 명시적으로 연결을 맺지 않으므로 비연결형 소켓이라 불린다. 메시지는 대상 소켓으로 전송되며, 대상 소켓은 메시지를 적절히 수신한다. 스트림 소켓보다 신뢰성이 떨어지지만 연결 설정에 드는 오버헤드는 무시할 수 없다. 클라이언트에서 서버로 데이터를 전송할 때 UDP를 사용하며, 메시지의 크기에 제한이 있고, 확실한 전달이 보장되지 않으며 통신 중 데이터가 손실되더라도 오류가 발생하지 않는다.

### 3. RAW

RAW 소켓은 패킷을 가져와 TCP/IP 스택의 TCP, UDP 계층을 우회하여 바로 애플리케이션으로 송신하는 소켓이다. 모든 데이터를 적절히 처리하거나 헤더를 제거하고 이를 파싱하는 과정을 수신 애플리케이션에서 담당해야 한다. RAW 소켓을 이용한 프로그래밍은 드물며, 시스템 소프트웨어나 패킷 분석 프로그램을 개발할 때 필요할 수 있다.

<br><br>

## UDP 소켓 프로그래밍

UDP를 사용하는 클라이언트/서버 모델에서는 연결 없이 통신이 이루어진다. 송신자는 각 패킷에 목적지 IP 주소와 포트 번호를 명시적으로 붙여서 전송한다. 애플리케이션 프로세스는 상대방의 IP 주소와 포트 번호를 항상 알고 있어야 하며, 수신자는 받은 패킷에서 송신자의 IP 주소와 포트 번호를 추출한다. UDP 서버 소켓은 닫지 않고 다른 UDP 연결을 기다린다.

<br><br>

## TCP 소켓 프로그래밍

TCP를 사용하는 클라이언트/서버 모델에서는 클라이언트가 서버에 접촉해야 한다. TCP는 연결을 설정하기 위해 소켓을 하나 더 열며, 서버 프로세스는 클라이언트의 접촉을 환영하는 소켓을 생성해둔다. 클라이언트가 서버에 접촉하는 과정은 다음과 같다:

1. 클라이언트는 TCP 소켓을 생성하고, 서버 프로세스의 IP 주소와 포트 번호를 지정한다.
2. 클라이언트가 소켓을 생성하면, 클라이언트 TCP는 서버 TCP와 연결을 설정한다.
3. 클라이언트의 접촉을 받으면, 서버 TCP는 특정 클라이언트와 통신하기 위한 새로운 소켓을 생성한다.

이 과정 후 클라이언트와 통신을 시작하며, 서버는 여러 클라이언트와 통신할 수 있다. TCP는 신뢰할 수 있는 순차적 바이트 스트림 전송을 제공한다.

<br><br>

# CDN = 콘텐츠 분배 네트워크


## CDN(Content Delivery Network)이란?

CDN은 지리적으로 분산된 서버들을 연결한 네트워크로서 웹 콘텐츠의 복사본을 사용자에 가까운 곳에 두거나 동적 콘텐츠(예: 라이브 비디오 피드)의 전달을 활성화하여 웹 성능 및 속도를 향상할 수 있게 한다. 각 CDN 서버는 "네트워크 에지"에 위치하며, 호스트 서버에 있는 웹 콘텐츠 일부를 저장하거나 캐싱한다. CDN은 사용자와의 거리를 줄여 웹사이트 퍼블리셔가 성능을 향상하고, 사용자가 경험하는 로딩 시간을 단축하며, 대역폭 소비 및 비용을 관리할 수 있다.

CDN은 다수의 지점에 분산된 서버들을 운영하며, 비디오 및 다른 형태의 웹 콘텐츠 데이터의 복사본을 이들 분산 서버에 저장한다. 사용자는 최선의 서비스와 사용자 경험을 제공할 수 있는 지점의 CDN 서버로 연결된다. CDN은 콘텐츠 제공자가 소유한 사설 CDN일 수도 있으며, 제3자가 운영하는 CDN을 통해 다수의 콘텐츠 제공자가 서비스할 수도 있다. 대표적인 제3자 운영 CDN으로는 Akamai, Limelight, 그리고 Level-3가 있다.

<br><br>

## CDN의 종류

CDN은 서버의 위치에 대해 두 가지 철학 중 하나를 채용한다:

| 종류 | 특징 | 장단점 |
| --- | --- | --- |
| Enter Deep | 서버 클러스터를 세계 곳곳의 접속 네트워크에 구축하여 ISP의 접속 네트워크로 깊숙이 들어가는 것이다. | - 서버를 최대한 사용자 가까이에 위치시켜 사용자가 CDN 서버 사이의 링크 및 라우터 수를 줄이고, 지연 시간 및 처리율을 향상시킨다.- 고도로 분산된 설계로 인해 서버 클러스터를 유지 관리하는 비용이 크다. |
| Bring Home | 적은 수의 핵심 지점에 큰 규모의 서버 클러스터를 구축하여 ISP를 Home으로 가져오는 개념이다. | - Enter Deep 방식에 비해 유지 및 관리 비용이 줄어들지만 사용자가 느끼는 지연시간과 처리율은 상대적으로 나빠진다. |
- enter deep : Client ISP network 안에
- bring home : 좀 더 윗단에 (관리는 쉽지만 client 입장에선 조금 느림)

![image](https://github.com/user-attachments/assets/87331377-b43d-465b-a347-3dc9baac4cde)



<br><br>

## CDN의 동작

CDN은 사용자 요청을 가로채고 클라이언트에게 가장 적당한 CDN 클러스터를 선택해 연결한다. 예를 들어, NetCinema가 KingCDN을 이용해 비디오를 분배한다고 가정하면 다음과 같은 과정이 일어난다:

1. 사용자가 NetCinema의 웹페이지를 방문한다.
2. 사용자가 특정 비디오 링크를 클릭하면, 사용자의 호스트는 해당 비디오에 대한 DNS query를 보낸다.
3. 사용자의 지역 DNS 서버는 query를 NetCinema의 책임 DNS 서버로 전달하고, NetCinema DNS 서버는 KingCDN으로 연결하기 위해 KingCDN의 호스트 이름을 LDNS에게 알려준다.
4. 이후, DNS query는 KingCDN의 사설 DNS 구조로 들어가며, 사용자가 콘텐츠를 전송받게 될 서버가 결정된다.
5. LDNS는 콘텐츠를 제공할 CDN 서버의 IP 주소를 사용자 호스트에게 알려준다.
6. 클라이언트는 KingCDN 서버의 IP 주소를 얻고 나면, 해당 IP 주소로 직접 TCP 연결을 설정하고 비디오에 대한 HTTP Get 요청을 전송한다.

![image](https://github.com/user-attachments/assets/e2ef8530-cfed-4fca-a4fc-2d33047af242)

<br><br>

# 웹 캐싱


## 웹 캐싱이란?

- `웹 캐시(web cache)`
    - 기점 웹 서버(origin Web server)를 대신하여 HTTP 요구를 충족시키는 네트워크 개체
    - 프록시 서버(proxy server)라고도 함
    - 웹 캐시는 자체의 저장 디스크를 가지고 있음→ 최근 호출된 객체의 사본을 저장 및 보존

웹 캐시는 기점 웹 서버(origin Web server)를 대신하여 HTTP 요청을 충족시키는 네트워크 개체이다. 브라우저는 사용자의 모든 HTTP 요청이 웹 캐시에 가장 먼저 보내지도록 설정할 수 있다. 웹 캐시가 객체의 사본을 저장하고 있다면, 요청된 객체는 기점 서버로부터 전송될 필요 없이 웹 캐시로부터 전송된다. 또한, 웹 캐시는 캐시 미스(cache miss)인 경우 기점 서버에서 요청된 객체를 받아 클라이언트로 전달하는 동시에 해당 객체를 자신의 저장소에 저장한다. 이를 통해 캐시는 같은 객체에 대한 후속 요청을 보다 신속히 처리할 수 있다.

<br><br>

### 웹 캐시 동작

1. 브라우저가 웹 캐시와 TCP 연결을 설정하고 HTTP 요청을 보낸다.
2. 웹 캐시가 객체의 사본을 저장하고 있는지 확인하고 있다면 이를 클라이언트로 전송한다.
3. 객체가 없다면 웹 캐시는 기점 서버와 TCP 연결을 설정하고 객체를 요청한다.
4. 기점 서버는 객체를 웹 캐시로 전송하며, 웹 캐시는 이를 클라이언트로 전달하고 자신의 저장장치에 복사본을 저장한다.

웹 캐시는 클라이언트의 응답 시간을 줄이고, 기점 서버의 트래픽 부하를 줄여 인터넷 성능을 향상시킨다. 웹 캐시를 통해 같은 객체를 여러 클라이언트가 요청하더라도 기점 서버에 반복적인 요청을 하지 않으므로 네트워크 효율성도 높아진다.


<br><br>

### 웹 캐시의 장점

웹 캐시는 응답 시간을 줄이고, 인터넷 트래픽을 감소시켜 비용을 절감할 수 있다. 예를 들어, 한 기관 네트워크에 웹 캐시를 설치하면 요청된 객체의 40%가 캐시에서 처리되어 응답 시간이 크게 줄어든다. 응답 시간 단축은 사용자 만족도 향상으로 이어진다. 또한, 웹 캐시는 대역폭 소비를 줄여 네트워크 비용 절감에 기여한다.

![image](https://github.com/user-attachments/assets/36424239-a6c2-452b-b0e5-b7f985b9cd8c)


![image](https://github.com/user-attachments/assets/f6663314-cefd-4022-8ab4-c9c5cdf788d8)

![image](https://github.com/user-attachments/assets/14b36a13-9555-4620-a7f0-82fe8baea650)
