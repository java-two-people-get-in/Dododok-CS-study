# 실행 컨텍스트와 호이스팅
## 실행 컨텍스트란?

- **실행 컨텍스트(Execution Context)** <br/>
: **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로, 
 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념

- 스택(stack): 선입후출 *like 우물
* 스택오버플로우(stack overflow): 스택이 넘칠 때 발생하는 에러
- 큐(queue): 선입선출 *like 양쪽이 열려있는 파이프*

<br/>

동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모두 컨텍스트를 구성하고, 이를 콜 스택(call stack)에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.

- 동일 환경(=하나의 실행 컨텍스트)를 구성하는 방법
    - 전역공간 *→ 자동 생성*

[콜스택의 실행 컨텍스트 쌓이는 순서 & 코드 실행에 관여하는 순서]

```jsx
// ------------------- (1)
var a = 1;
function outer() {
	function inner() {
		console.log(a); // undefined
		var a = 3;
	}
	inner();  // -------- (2)
	console.log(a);   // 1
}
outer();    // -------- (3)
console.log(a);     // 1
```
<br/>

![image](https://github.com/user-attachments/assets/c65551d8-99a7-4191-bacb-8624c3befc58)

이렇게 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다. 이는 개발자가 코드를 통해 확인할 수는 없으며, 담기는 정보는 다음과 같다.

<br/><br/>

**[실행 컨텍스트 수집 정보]**

- **`VariableEnvironment`**: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음.
- **`LexicalEnvironment`**: 처음에는 VariableEnvironment와 같지만, 변경 사항이 실시간으로 반영됨.
- **`ThisBinding`**: this 식별자가 바라봐야 할 대상 객체

![image](https://github.com/user-attachments/assets/baf353cf-9b7c-493e-b451-2f88a785db3d)

![image](https://github.com/user-attachments/assets/59dc3556-27e5-4568-8428-ce51f227c726)

<br/>

**[Quiz!]**

```jsx
var TVChannel; // undefined

console.log(TVChannel);

TVChannel = "Netflix";

console.log(TVChannel);
```

- 설명
    
    // undefined (에러X)
    
    // Netflix
    
    **호이스팅 (Hosting)**
    : 선언문이 마치 최상단에 끌어올려진 듯한 현상<br/>
    
    → 물리적으로 선언 코드를 끌어올린 것이 아니라, 자바스크립트 엔진이 먼저 전체 코드를 스캔하면서<br/> 변수같은 정보를 실행 컨텍스트 어딘가에 미리 기록해두기 때문
    <br/>
    ⇒ 이것이 바로 Record!
    
<br/>

### VariableEnvironment

: 담기는 내용은 **`LexicalEnvironment`**와 같지만, 최초 실행 시의 스냅샷을 유지한다는 점이 다르다.

실행 컨텍스트 생성 시,

- **`VariableEnvironment`**에 정보를 먼저 담은 다음,
- 이를 복사해 **`LexicalEnvironment`**를 만들고 이후에는 **`LexicalEnvironment`**를 주로 활용한다.

```
📖 `VariableEnvironment`와 `LexicalEnvironment`*의 내부는
`environmentRecord`와 `outer-EnvironmentReference`로 구성되어 있다!
```

<br/>

### LexicalEnvironment

: **‘사전적인 환경’**

ex) “현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고, 
      그 외부 정보는 D를 참조하도록 구성돼있다.”

<br/>

### - environmentRecord와 호이스팅

- `environmentRecord (환경 레코드)`란?
: 현재 컨텍스트와 관련된 코드의 **식별자** 정보들이 저장
(식별자와 식별자에 바인딩 된 값을 **기록**)
*ex) 매개변수명, 함수 선언, 변수명 등*
    
    ⇒ 컨텍스트 내부 전체를 **순서대로** 훑어가며 수집한다!
    
<br/>

```
📖

참고
_
전역 실행 컨텍스트는 변수 객체를 생성하는 대신, 자바스크립트 구동 환경이 별도로 제공하는 전역객체(global object)를 활용한다. 전역 객체에는 브라우저의 window, Node.js의 global 객체 등이 있다. 이들은 자바스크립트 내장 객체(native object)가 아닌, 호스트 객체(host object)로 분류된다.

```

## 호이스팅
- 호이스팅(hoisting)이란? <br/>
: ‘끌어올리다’라는 의미의 동명사로, 변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념. <br/>자바스크립트 엔진이 실제로 끌어올리지는 않지만, 편의상 끌어올린 것으로 간주하는 것.
    
    ⇒ 코드 실행 전, 변수 정보 수집 과정을 마친 JS 엔진은, 이미 해당 환경에 속한 코드의 변수명을 모두 알고 있다. 이를 ‘자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다’라고 생각하는 것!
    

<br/>

**[다시 보기]**

```jsx
console.log(TVChannel);

var TVChannel = "Netflix";

console.log(TVChannel);
```

<br/>

1. 생성 단계 : 선언문만 실행해서 Environment Record에 기록

![image](https://github.com/user-attachments/assets/ac7cb004-754d-4593-b130-e65d3d1147c4)

→ 2. 실행 단계 : 선언문 외 나머지 코드 순차 실행. Environment Record 참조하거나 업데이트

- **Variable Hoisting**
    - var → 선언과 초기화(암묵적 undefined 값 바인딩)가 동시
    - let, const →선언 이전의 식별자를 참고할 수 없음 (Temporal Dead Zone)
- **Function Hoisting**
    - 함수 자체가 호이스팅

<br/>

**[ 호이스팅 규칙 ]**

```jsx
1️⃣ 원본 코드

function a(x) {   // 수집대상 1(매개변수)
	console.log(x); // (1) (예상  1
	var x;          // 수집대상 2(변수 선언)
	console.log(x); // (2) (예상  
  var x = 2;      // 수집대상 3(변수 선언)
  console.log(x); // (3) (예상  
}
a(1)
```

```jsx
2️⃣ 매개변수를 변수 선언/할당과 같다고 간주해 변환한 상태

function a(x) { 
  var x = 1;      // 수집대상 1(매개변수)
	console.log(x); // (1)
	var x;          // 수집대상 2(변수 선언)
	console.log(x); // (2)
  var x = 2;      // 수집대상 3(변수 선언)
  console.log(x); // (3)
}
a();
```

```jsx
3️⃣ 호이스팅을 마친 상태

function a(x) { 
  var x;          // 수집대상 1의 변수 선언 부분
  var x;          // 수집대상 2의 변수 선언 부분
  var x;          // 수집대상 3의 변수 선언 부분

  x = 1;          // 수집대상 1의 할당 부분
	console.log(x); // (1) (결과 1!)
	console.log(x); // (2) (결과 1!)
  var x = 2;      // 수집대상 3의 할당 부분
  console.log(x); // (3) (결과 2!)
}
a(1);
```

```
📖 (1) 1, (2) undefined, (3) 2 라는 예상과 달리, <br/>
실제로는 (1) 1, (2) 1, (3) 2 라는 결과가 나왔다.  <br/>
→ 정확한 호이스팅 개념을 알아야 함!

```

<br/>

실행 컨텍스트가 생성되면,

- **[호이스팅]** 변수명과 함수 선언의 정보를 위로 끌어올린다(수집한다).
    
    : 1) 변수는 선언부와 할당부를 나누어 선언부만, 
      2) 함수 선언은 함수 전체를 
    
     끌어올린다.
    
- **[호이스팅 이후]** 함수 선언문은 함수 표현식으로 변경한다.
    
    ```jsx
    var b = function b () { };  // <- 바뀐 부분
    ```
    
<br/>

- 풀어보기
Q. 아래 코드에서 (1), (2), (3)의 출력 결과는?
    
    ```jsx
    function a () {
      ~~var b;~~
      function b () { console.log("hello"); } 
    	console.log(b);   // (1)
    	b = 'bbb';    // 수집대상 1(변수 선언)
    	console.log(b);   // (2)
    	                     // 수집대상 2(함수 선언)
    	console.log(b);   // (3)
    }
    a();
    ```
    
    - A. 정답확인
        
        ```jsx
        function a () {
            var b;           // 변수 선언 (초기 값 undefined)
            function b () {} // 함수 선언 (함수 자체가 호이스팅)
            
            console.log(b);  // (1)
            b = 'bbb';       // 변수 재할당
            console.log(b);  // (2)
            console.log(b);  // (3)
        }
        ```
        
        (1) b 함수, (2) ‘bbb’, (3) ‘bbb’
        
<br/>

### - 정리

**`Keyword`**

- **실행 컨텍스트**: 실행할 코드에 제공할 환경 정보들을 모아놓은 객체
- 전역 컨텍스트(자동생성), eval 및 **함수 실**행에 의한 컨텍스트 등
- 실행 컨텍스트 객체는 활성화되는 시점에
**`VariableEnvironment`**, **`LexicalEnvironment`**, **`ThisBinding`**의 세 가지 정보를 수집

---

- **호이스팅**: 코드 해석을 수월하게 하기 위해 `environmentRecord`의 수집 과정을 추상화한 개념
”실행 컨텍스트가 관여하는 코드 집단의 최상단으로 그들을 끌어올린다.”
- 변수 선언: 선언부만을 호이스팅
함수 선언: 함수 전체를 호이스팅
- → 여기서, 함수 선언문과 함수 표현식의 차이 발생
