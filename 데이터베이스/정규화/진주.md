# 정규화

### 정규화(Normalization)

정규화란 이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정이다. 이상현상이 존재하는 릴레이션을 분해하여 여러 개의 릴레이션을 생성하게 된다. 이를 구분하여 정규형이 높아질수록 이상현상은 줄어들게 된다.

즉, 쉽게말하면 테이블 간에 중복된 데이터를 허용하지 않는다는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다. 이러한 테이블을 분해하는 정규화 단계가 정의 되어 있다.

<br/>

### 정규화의 장단점

**정규화의 장점**

- 데이터베이스 변경 시 이상 현상(Anomaly)을 제거할 수 있다.
- 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
- 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되어 응용프로그램의 생명을 연장시킨다.

<br/>

**정규화의 단점**

- 릴레이션의 분해로 인해 릴레이션 간의 JOIN연산이 많아진다.
- 질의에 대한 응답 시간이 느려질 **수도** 있다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다.
- 따라서 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있다.
- 만약 조인이 많이 발생하여 성능 저하가 나타나면 **반정규화(De-normalization)**를 적용할 수도 있다.

<br/>


### 제1정규화(1NF)

**= 하나의 칸 안에는 하나의 데이터만!**

제 1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것이다.
<br/>
제 1 정규화는 다음과 같은 규칙들을 만족해야한다.

1. 각 컬럼이 하나의 속성만을 가져야한다.
2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야한다.
3. 각 컬럼이 유일한 이름을 가져야한다.
4. 칼럼의 순서가 상관없어야한다.

![image](https://github.com/user-attachments/assets/f360a885-af3d-4b37-aa9a-9ca9c68e4b15)

<br/>

### 제2정규화(2NF)

**= 현재 테이블의 주제와 관련이 없는 컬럼을 다른 테이블로 빼는 것!**

제 2정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다. 여기서 완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.

제 2정규화는 다음과 같은 규칙을 만족해야한다.

1. 제 1정규화를 만족해야한다.
2. 모든 컬럼이 부분적 종속(Partial Dependency)이 없어야한다. 모든 칼럼이 완전 함수 종속을 만족해야한다.

[정확한 정의] partial dependency를 제거한 테이블

- Partial Dependency란?
    - 하나의 Composite primary key에 종속된 것
        
        → 이를 이 컬럼을 다른 테이블로 빼버리면 제2정규화를 만족하게 됨
        
        (*Composite primary key가 없다면, partial key도 없다!)
        
        ![image](https://github.com/user-attachments/assets/7e4d0a58-4cf2-47a3-8542-f5fbb14ebfcc)

    - Composite primary key(=합하면 primary key 역할을 할 수 있는 것들)

EX) 제 1정규화 테이블을 예시로 들자면,

![image](https://github.com/user-attachments/assets/a40a981f-caef-4a8b-acd2-59af98d25ddd)

![image](https://github.com/user-attachments/assets/5d1720c6-2e57-435d-9415-66255c3c9962)

→ 한 곳(ex. 헬스 가격)만 수정하면 됨

- 장점: 수정 등의 작업 편리
- 단점: 여러 개의 테이블을 조회해야 하는 경우 존재 (ex. 손흥민이라는 사람이 얼마를 내야 하는지) - 하나의 테이블만으로는 알 수 없고 다른 테이블에서 데이터를 끌어와야 함

<br/>

### 제3정규화(3NF)

**= 일반 컬럼에만 종속된 컬럼을 다른 테이블로 빼는 것**

제 3정규화란 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. 여기서 이행적 종속이라는 것은 A->B, B->C가 성립할 때 A->C가 성립되는 것을 의미한다.
<br/>
제 3 정규화는 다음과 같은 규칙을 만족해야 한다.

1. 제 2 정규화를 만족해야한다.
2. 기본키를 제외한 속성들 간의 이행 종속성(Transitive Dependency)이 없어야한다.
- 이행적 함수적 종속관계: 뭐 하나를 거쳐서 종속관계가 만들어지는 것

EX) 이와 같은 테이블이 있다고 가정하자

![image](https://github.com/user-attachments/assets/c05fd51a-392b-43e4-b96a-0a89748dc7ef)

![image](https://github.com/user-attachments/assets/f420384d-24a3-4dbc-b930-776451a945fb)

→ ex. 제2정규화까지 했다면, 예를 들어 이상구씨의 출신대학이 바뀌면 여러개의 데이터를 바꾸어야 함. but, 제3정규화까지 했다면 한 곳의 데이터만 바꾸면 됨

- 단점: 위와 동일 (다른 테이블을 참조해야 하는 경우가 있음)

*⇒ 관계형 데이터들은 제3정규화까지 해두는 게 일반적*

<br/>

### BCNF(Boyce-codd Normal Form)

BCNF는 3차 정규화를 조금 더 강화한 버전이다. 이는 3차 정규화에서 해결할 수 없는 이상현상을 해결할 수 있다. BCNF란 3차 정규화를 만족하면서 모든 결정자가 후보키 집합에 속한 정규형이다.
<br/>
BCNF는 다음과 같은 규칙을 만족해야 한다.

1. 제 3 정규화를 만족해야 한다.
2. 모든 결정자가 후보키 집합에 속해야 한다.
