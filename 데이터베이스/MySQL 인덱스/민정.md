# [데이터베이스] 인덱스

## 인덱스란(index, 색인)?
데이터를 쉽고 빠르게 찾기 위해 투플의 키 값에 대한 물리적 위치를 기록해둔 자료구조이다.

책이나 잡지를 볼 때 원하는 내용을 찾을 때 모든 페이지를 살펴본다면 오랜 시간이 소요된다. 하지만 책이나 잡지에는 색인을 추가해서 내용을 찾을 수 있도록 도움을 준다. 데이터베이스에 Index 또한 같은 역할을 한다.


## 인덱스 사용 이유
![image](https://github.com/user-attachments/assets/a92b7384-9d2a-4691-9123-64c3f147ebca)

위 예시에서 SELECT 문을 활용해 SCOUNTER 테이블에 있는 AIRPORT Column에 있는 LCY라는  값을 조회한다고 해보자.
그렇다면 SELECT 문은 모든 테이블에 있는 데이터를 모두 조회한 후 최종적으로 LCY 가 포함된 모든 값들을 반환하는 로직으로 작동할 것이다. 
인간이 위 테이블을 직관적으로 봐서 결과를 찾아낼 때에는 LCY가 마지막으로 들어 있는 "위치"를 알고 아래 데이터들은 무시할 수 있다. 하지만 데이터베이스 조회 구문은 LCY 값의 마지막 위치가 어디인지 모르기 때문에 데이터 전체를 탐색함으로써 
결과를 반환해준다. 그리고 만약 데이터가 수십만 개가 들어 있을 때 조회 기능이 자주 실행되는 서비스가 있다면 계속해서 데이터베이스를 처음부터 끝까지 조회하면 값을 반환하기 때문에 트래픽에 따라 성능이 저하될 수밖에 없다. 
그래서 데이터베이스에서도 이러한 문제점을 방지하고자 "Index"를 활용해 자주 조회되는 Column 에 대한 Index Table을 따로 만들어 SELECT 문이 들어왔을 때 Index 테이블에 있는 값들로 결과 값을 조회해 온다. 
그래서 Index를 잘 사용한다면 "검색" 연산을 실행했을 때 성능을 드라마틱하게 올릴 수 있게 된다.

## 인덱스의 특징
- 테이블에서 한 개 이상의 속성을 이용해 생성한다.
- 빠른 검색과 함께 효율적인 레코드 접근이 가능하다.
- 순서대로 정렬된 속성과 데이터의 위치만 보유하므로 테이블보다 작은 공간을 차지한다.
- 데이터의 수정, 삭제 등의 변경이 발생하면 인덱스의 재구성이 필요하다.
- 일반적으로 B-tree 형태의 구조를 가진다.

## 인덱스의 구조
일반적인 RDBMS의 인덱스는 대부분 B-tree 구조로 되어있고, B-tree는 데이터의 검색 시간을 단축하기 위한 자료구조이다.

- B-tree의 구조 
![image](https://github.com/user-attachments/assets/a75676d8-1673-45a2-a956-3e021cdff806)
  - 루트 노드(root node), 내부 노드(internal node), 리프 노트(leaf node)로 구성된다.
  - 각 노드는 Key값과 포인터를 가진다.
    - 위의 이미지에서 파란색 부분이 Key값, 빨간색 부분이 자식 노드들을 가리키는 포인터이다.
  - key들은 노드 안에서 항상 오름차순으로 정렬된 값을 가지며, 이진검색 트리처럼 각 key들의 왼쪽 자식들은 항상 key보다 작은 값을, 오른쪽은 큰 값을 가진다.
  - 모든 검색은 루트 노드에서부터 시작해 내부 노드를 지나 리프 노드까지 내려가면서 이루어진다
  - 키 값이 새로 추가되거나 삭제될 경우 동적으로 노드를 분할하거나 통합해 항상 균형 상태를 유지한다.
  - 데이터를 검색할 때 특유의 트리 구조를 이용하기 때문에 한 번 검색할 때마다 검색 대상이 줄어 접근 시간이 적게 걸린다. 100만 개의 튜플을 가진 데이터도 3~4번의 디스크블록을 읽으면 찾을 수 있다.

## index를 통해 데이터를 어떻게 조회하는 방법
![image](https://github.com/user-attachments/assets/6c1053db-1358-46d9-8208-459bd7368078)
첫번째로 root node로 가서 age = 22인 값의 leaf노드로 가기위한 경로를 안내받는다.
root node는 branch node의 경로를 안내해주고 branch node로 가면 또 아래의 branch node혹은 leaf node의 경로를 알려줄 것이다.
그렇게 leaf node까지 도착하게 되면 leaf node는 index 의 값과 디스크의 주소값을 가지고 있다.
디스크 주소값을 이용해 디스크까지 접근한 후, 디스크 I/O가 발생하고 age 22에 저장되어있는 디스크 B주소로 접근하게 된다.
그러면 최종적으로 디스크 B주소에 있는 철수 라는 데이터를 가져오고 조회결과를 보여주게 된다.
 
 
## 인덱스 종류
  - 클러스터 인덱스(clustered index)
  ![image](https://github.com/user-attachments/assets/5444645a-b2db-4f8e-8e62-4ce5142d2482)

    - 테이블 생성 시 기본키(PK)를 생성하면 자동으로 클러스터형 인덱스가 생성된다. 해당 컬럼 기준으로 정렬이 된다.

  - 보조 인덱스(secondary index)
 
## 인덱스(index)의 관리
DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가함
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함
 
## 인덱스를 사용하면 좋은 경우
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼
