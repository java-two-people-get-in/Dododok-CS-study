# 다익스트라 알고리즘(Dijkstra Algorithm)

다익스트라 알고리즘은 **음의 가중치**(음의 간선, 음의 값)**가 없는 그래프의 한 노드**에서 **각 모든 노드까지의 최단거리를 구하는 알고리즘**을 말한다.<br/><br/>


다익스트라 알고리즘은 **그리디 알고리즘**이자 **다이나믹 프로그래밍 기법을 사용한 알고리즘**이라고 볼 수 있다. (‘최단 거리는 여러 개의 최단 거리로 이루어져있기 때문’)

⇒ 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다!

<br/><br/>

다익스트라 알고리즘의 메커니즘은 기본적으로

아래 두 단계를 반복하여 임의의 노드에서 각 모든 노드까지의 최단거리를 구하는 문제에서 활용할 수 있다.

임의의 노드에서 다른 노드로 가는 값을 비용이라고 한다.

- **방문하지 않은 노드** **중**에서 **가장 비용이 적은 노드를 선택**한다(그리디 알고리즘)
- **해당 노드로부터 갈 수 있는 노드들의 비용을 갱신**한다(다이나믹 프로그래밍)

가능한 적은 비용으로 가장 빠르게 해답에 도달하는 경로를 찾아내는 대부분의 문제에 응용되며, 적용하는 문제를 그림으로 살펴보며 이해해 보자.

![image](https://github.com/user-attachments/assets/5f355630-711b-49b6-938c-3b6363ffbd35)

1. 컴퓨터는 기본적으로 당장 하나씩 밖에 계산하지 못함. 지금 당장은 1→ 3의 최소 비용이 6이다.

![image](https://github.com/user-attachments/assets/b750a95b-2f81-4741-a5f3-57660d99eaab)

2. 위와 같이 컴퓨터는 경로 1→3의 비용이 6인데에 반해 경로 1→2→3이 총 비용 4로 저렴하다는 것을 알게 된다. 이때, 최소 비용을 6에서 4로 갱신한다!

⇒ 이처럼 다익스트라 알고리즘은 ‘현재까지 알고 있던 최단 경로를 계속해서 갱신’하는 것

<br/><br/>

### 구체적인 동작 과정

1. 출발 노드 설정
2. 출발 노드 기준 각 노드의 최소 비용 저장
3. 방문하지 않은 노트 중 가장 비용 적은 노드 선택
4. 해당 노드를 거쳐 특정 노드로 가는 경우를 고려해 최소 비용 갱신
5. 위의 과정에서 3~4번을 반복

<br/><br/>


## 다익스트라 알고리즘 그림 설명

**A노드에서 출발하여 F노드로 가는 최단 경로를 구하는 문제**를 다익스트라 알고리즘을 활용한다.

아래의 각 데이터의 의미를 보며 살펴보자

- S = 방문한 노드들의 집합
- d [N] = A → N까지 계산된 최단 거리
- Q = 방문하지 않은 노드들의 집합
- 확인되지 않은 거리는 전부 초기값을 무한으로 잡는다 ex) INF

1. **루프를 돌려 이웃 노드를 방문하고 거리를 계산한다.**

![image](https://github.com/user-attachments/assets/637d3ced-30de-44da-9a91-e5b4530f0085)

**2. 첫 루프 이후의 그래프의 상태가 업데이트되는 방식**

![image](https://github.com/user-attachments/assets/462bdaad-5a73-41a4-9290-8b08900ba94b)

**3. 더 빠른 경로를 발견한 경우 ( d[C] = 5->4 ) 값 업데이트**

이런 식으로 방문하지 않은 노드 중 비용이 적은 노드를 선택하여 가까운 노드의 비용**(그리드 알고리즘)과**

해당 노드로부터 갈 수 있는 노드들의 비용을 갱신한다. **(다이나믹 프로그래밍)을** 반복하여 사용한다.

![image](https://github.com/user-attachments/assets/d2712cb8-720a-4a66-b00b-712d4a8238fd)

**3.1 더 빠른 경로를 발견한 경우 ( d[E] = 10->6 , d[F] = 11->9) 값 업데이트**

![image](https://github.com/user-attachments/assets/1bf8cc46-d596-4e25-b368-47148cb3f883)

**4. E노드에 왔을 때 d[F] = 9 -> 8 값 업데이트**

![image](https://github.com/user-attachments/assets/d28ebdaa-5966-4c4a-95db-5587cdac6781)

**5. 이 일련의 과정이 반복되어 Q가 공집합이 되었다면, 남아 있는 데이터로 추론하여 최단 거리를 결정한다.**
    
    [최단 경로]  A→D→C→E->F
    
    [거리] 8
    

![image](https://github.com/user-attachments/assets/cbf6ab5d-0d0a-439d-bb19-8e65d71202e1)

<br/><br/>


## 정리

실제로 컴퓨터 안에서 처리할 때는 2차원 배열을 이용해 테이블의 형태로 각 노드 간의 비용을 정의

A를 기준으로 본다면

| 0 | 2 | 5 | 3 | 무한 | 무한 |
| --- | --- | --- | --- | --- | --- |

여기서 A → C의 경로는 A→D→C가 더 비용이 적으므로 (4<5) 4로 업데이트!

| 0 | 2 | **4** | 3 | 6 | 10 |
| --- | --- | --- | --- | --- | --- |

<br/><br/>


## 구현 방법

- **선형탐색(반복문 이용)  O(V^2)**
    - 한 번 방문한 배열은 방문할 수 없으므로 방문 여부를 체크할 배열이 필요할 것이고, 각 노드 까지의 최소 비용을 저장할 배열이 필요할 것이다.
- **우선순위 큐 이용 O((V+E)log V)**
    - **갱신하는 주변 노드의 값에 대해서만 다음 최소 비용을 갖는 노드를 선택해주면 된다는 것이 우선순위큐를 이용하는 것의 핵심**

<br/><br/>


## 다익스트라 알고리즘 특징

**장점**

- 인접 행렬 또는 우선순위 대기열을 사용하여 구현할 수 있으므로 가능한 모든 경로를 확인하는 무차별 접근 방식보다 효율적이다.
- 거리뿐만 아니라 경로를 추적하도록 알고리즘을 쉽게 수정할 수 있다.

**단점**

- 우선순위 대기열을 사용할 때 간선이 많은 큰 그래프의 경우 느려질 수 있다.
- 그래프와 거리를 저장하려면 많은 양의 메모리가 필요하다.
- 동일한 거리에 여러 경로가 있는 경우 최상의 경로를 보장하지 않는다.
