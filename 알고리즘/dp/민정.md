# DP(다이나믹 프로그래밍 / 동적 계획법)란?

```sql
복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 알고리즘 설계 기법
```

# DP 조건

DP를 적용하기 위해서, 두 가지 속성을 만족시켜야 한다.

1. **부분 반복 문제 (Overlapping Subproblem)**

이미 진행했던 연산임에도 반복적으로 연산되는 것을 의미한다.

ex) 피보나치 수열에서 f(4)를 구하기 위해 f(3), f(2)가 호출되고, f(3)을 구하기 위해 f(2), f(1)이 호출되는 등 이미 진행됐던 f(2)가 반복 호출되는 것은 부분 반복 문제가 성립된다.

2. **최적 부분 구조 (Optimal Substructure)**

작은 부분 문제에서 구한 최적이 답으로 합쳐진 큰 문제의 처적의 답을 구할 수 있어야 함을 의미한다.

ex) 큰 문제의 답인 fibo(n) 이 최적의 답이 되려면, 작은 부분의 문제인 fibo(n-1), fibo(n-2)이 최적의 답이어야만 한다. **작은 부분의 문제의 최적의 답으로 큰 문제의 최적의 답을 구한다는 뜻이다.**

# DP로 문제 푸는 방법

1. 변수 간 관계식(점화식) 만들기

ex) 피보나치 수열의 f(n) = f(n-1) + f(n-2)

2. 결과 저장하기

변수 값에 따른 결과를 저장할 배열 등을 미리 만들고, 결과가 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

```sql
dp[0] = 0
dp[1]= 1
```

3.  값 기록해 나가기
N번째 피보나치 수를 구하기 까지 관계식들을 통해 앞의 피보나치 수들을 구해 나가며 그 값을 배열에 기록해주면 됩니다.

```sql
for i in range(2, N+1):
    dp.append(dp[i-2] + dp[i-1])
```

# DP의 2가지 접근 방법

1. **Bottom-up 방법 - 반복문 사용**

작은 문제에서부터 해결하여 점차 큰 문제를 풀어가는 방식이다. 
반복문을 사용하여 부분 문제들을 해결하고, 결과를 배열 등에 저장한다.

> 👍 일반적으로 더 직관적이고 이해하기 쉽습니다. 또한, 모든 작은 부분 문제를 해결하므로 최적 부분 구조를 보장합니다.
> 

```sql
# 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
dp = [0] *100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n=99

for i in range(3,n+1):
	d[i] = d[i-1]+d[i-2]
```

2. **Top-Down (Memoization 방식) - 재귀 사용**

큰 문제를 작은 부분 문제로 나누어 해결하는 방식이다. 
재귀 함수를 사용하여 문제를 작은 부분 문제들로 쪼개고, 중복 계산을 피하기 위해 이전에 계산한 값을 저장하는 Memoization을 활용합니다.

- 메모이제이션(Memoization)이란?
    
    > 컴퓨터 프로그램이 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술
    > 
    
    즉, 메모리에 계산한 값을 저장해 나감으로써 반복 수행될 때 연산 없이 저장된 값을 사용한다는 개념이다.
    
    ```sql
    def fibo(n: int):
        cache = [0, 1]
        
        for num in range(2, n + 1):
            cache.append(cache[num - 1] + cache[num - 2])
        
        return cache[n]
    ```
    
    배열을 생성하고, 계산한 값을 저장하고, 저장된 값일 경우 배열의 값을 리턴하는 형식으로 코드를 구현할 수 있다. 이렇게 하게 되면 연산의 중복을 막을 수 있다. 주로 저장을 해두는 메모리를 cache라고 부른다.
    

> 👍 Memoization은 재귀를 사용하므로 구현이 더 간단할 수 있습니다. 또한, 필요한 부분 문제만 해결하므로 계산 시간을 절약할 수 있습니다. 하지만 재귀 호출의 오버헤드가 발생할 수 있으며, 모든 작은 부분 문제를 해결하지 않을 경우 최적 부분 구조를 보장하지 않을 수 있습니다
> 

```sql
# 한 번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
dp = [0] *100

def fibo(x):
	# 종료 조건
	if x == 1 or x==2:
		return 1
	# 이미 계산한 적 있는 문제라면 그대로 반환
	if d[x] !=0:
		return d[x]
	# 아직 계산하지 않은 문제라면 점화식에 다라서 피보나치 결과 반환
	d[x] = fibo(x-1) + fibo(x-2)
	return d[x]
```

DP 문제들은 점화식을 세워 중간에 계산해 놓은 값들을 다음 단계에서 활용하는 것이 핵심인 유형이에요!
