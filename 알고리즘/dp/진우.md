# [알고리즘] DP

## 1. DP?

**다이나믹 프로그래밍(또는 동적 계획법)**

> **하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용**하는 것
> 

→ 작은 문제의 결과를 **저장** 하여 사용하는 것. → 캐시!

## 2. 예시 - 피보나치

Q. 입력으로 n이 주어졌을 때, n번째 피보나치 수열을 구하는 프로그램을 작성하라. (n≤100)

```jsx
def fibo(n):
	if n==0 :
		return 1
	elif n==1 :
		return 1
	return fibo(n-1) + fibo(n-2)
```

![image](https://github.com/user-attachments/assets/4319fdf9-2566-4668-a8ea-c8bcc0ecc446)


### fibo(10)를 사용할 떄, 하위 함수를 몇 번 호출할까?

- fibo(10): 1번
- fibo(9): 1번
- fibo(8): 2번
- fibo(7): 3번
- fibo(6): 5번
- fibo(5): 8번
- fibo(4): 13번
- fibo(3): 21번
- fibo(2): 34번
- fibo(1): 55번
- fibo(0): 34번

→ 총 177번 호출

### fibo(50)은?

dp를 사용하지 않는 경우, $O(2^n)$의 시간 복잡도를 가지며, 약 1조번의 호출이 발생함.

### dp를 사용한다면?

- fibo(50) 호출 → fibo(49) + fibo(48)
- fibo(49), fibo(48)의 값을 계산한다.
    1. 재귀적으로 fibo(48) + **fibo(47)**을 호출하게 된다.
    2. 재귀적으로 **fibo(47)** + fibo(46)을 호출하게 된다.
    3. 재귀적으로… 호출하여 모든 fibo(0)까지 호출한다.

이 과정에서, 처음 fibo(47)을 호출한 후, **해당 결과를 1차원 배열에 저장**해 놓는다.(메모이제이션)

두 번째로 fibo(47)을 호출할 때에는, fibo(46) + fibo(45)를 수행하는 것이 아니라, **저장된 배열에 존재하는지 확인후 값을 가져온다.**

→ $O(N)$의 시간 복잡도

## 탑다운 dp와 바텀업 dp

### 탑다운 dp (재귀)

- 말 그대로, 위에서부터 아래로 내려오며 문제를 해결해 나가는 방식
- 이미 계산한 값을 저장하고, 다시 호출할 때 그 값을 재사용하는 방식
- main함수에서 fibo(50)을 호출함

```python
def fibo(n):
    # 메모이제이션을 위해 이미 계산된 값이 있다면 그 값을 반환
    if dp[n] != -1:
        return memo[n]
    
    # 기본 케이스: n이 0 또는 1일 때
    if n == 0 or n == 1:
        return 1
    
    # 재귀적으로 피보나치 값을 구하고, 메모에 저장
    dp[n] = fibo(n - 1) + fibo(n - 2)
    
    return dp[n]

# 메모이제이션을 위한 배열
dp= [-1] * 100

# 예시: 50번째 피보나치 수를 구하기
n = 50
print(fibo(n))

```

### 바텀업 dp (반복문)

- 아래에서부터 위로, 계산해 나가며 정답을 찾는 방식
- fibo(0), fibo(1)의 값을 통해 fibo(50) 까지 계산한다.

```python
def fibo_dp(n):
    # 피보나치 수를 저장할 배열
    dp = [0] * (n + 1)
    
    # 초기값 설정
    dp[0] = 1
    dp[1] = 1
    
    # DP를 사용하여 피보나치 수 계산
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]

# 예시: 50번째 피보나치 수를 구하기
n = 50
print(fibo_dp(n))

```
