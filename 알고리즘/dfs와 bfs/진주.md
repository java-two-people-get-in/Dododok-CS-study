# DFS / BFS

### **1. 깊이 우선 탐색 (DFS, Depth-First Search)**

: 최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동

![image](https://github.com/user-attachments/assets/a6388317-d827-434a-b934-0d258341c7eb)

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 
**해당 분기를 완벽하게 탐색**하는 방식

1. 모든 노드를 방문하고자 하는 경우에 이 방법을 선택

2. 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 **좀 더 간단**

3. 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 **느림**

4. **Stack** 혹은 **재귀함수(Recursion)**으로 구현

<br/><br/>

### **2. 너비 우선 탐색 (BFS, Breadth-First Search)**

: 최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동

![image](https://github.com/user-attachments/assets/68eeb0ee-e4fb-4684-9e56-23b3cd2ed472)

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 **인접한 노드를 먼저** **탐색**하는 방법으로, 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
1. 주로 두 노드 사이의 **최단 경로**를 찾고 싶을 때 이 방법을 선택
    
    ex) 지구 상에 존재하는 모든 친구 관계를 그래프로 표현한 후 A과 B사이에 존재하는 경로를 찾는 경우
    
    - 깊이 우선 탐색의 경우 - 모든 친구 관계를 다 살펴봐야 할지도 모름
    - 너비 우선 탐색의 경우 - A과 가까운 관계부터 탐색
2. **Queue**를 사용해서 구현

| **DFS(깊이우선탐색)** | **BFS(너비우선탐색)** |
| --- | --- |
| 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색 | 현재 정점에 연결된 가까운 점들부터 탐색 |
| 스택 또는 재귀함수로 구현 | 큐를 이용해서 구현 |

<br/><br/>

## **DFS와 BFS의 시간복잡도**

**시간 복잡도**

- 인접 리스트 : O(V + E)
- 인접 행렬 : O(V^2)

두 방식 모두 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일하다.

DFS와 BFS 둘 다 다음 노드가 방문하였는지를 확인하는 시간과 각 노드를 방문하는 시간을 합하면 됨!

N은 노드, E는 간선일 때

> 인접 리스트 : O(N+E)
> 

일반적으로 E(간선)의 크기가 N²에 비해 상대적으로 적기 때문에

인접 리스트 방식이 효율적임
