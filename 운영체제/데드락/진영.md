## DeadLock이란?
>교착상태라고 말하며 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 말한다. 이러한 교착상태를 해결하는 것도 운영체제의 중요한 역할이다.

![](https://velog.velcdn.com/images/ozziny/post/bfd927f4-a4d5-4ea1-bb6f-ca190d74cc36/image.png)

위의 상황에서 게임은 자원 A를 가지고 있고 웹브라우저가 가지고있는 자원 B를 기다리고
웹 브라우저는 자원B를 가지고 있고 게임이 가지고있는 자원A를 기다리는 경우 서로의 자원을 평생 기다리는 교착상태가 발생하게 된다.
<br/>

## 데드락(Deadlock)이 발생하는 조건 4가지
> 아래 네 가지 조건을 모두 만족할 시, 교착 상태가 발생할 수 있다.

<br/>

**상호 배제(Mutual Exclusion)**
자원은 **한 번에 한 프로세스만이 사용**할 수 있어야 한다.
<br/>

**점유 대기 (Hold and Wait)**
최소한 하나의 **자원을 점유**하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 **점유하기 위해 대기**하는 프로세스가 있어야 한다.

즉, 이미 자원을 사용중인데, 다른 프로세스가 사용중인 자원을 사용하기 위해 대기하고 있는 상태의 프로세스가 존재해야 한다.
<br/>

**비선점 (No preemption)**
다른 프로세스에 할당된 자원은 사용이 끝날 때까지 **강제로 빼앗을 수 없어야** 한다.
<br/>

**순환 대기 (Circular wait)**
프로세스의 집합에서 P0은 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고, P2...Pn-1d은 Pn이 점유한 자원을 대기하며 Pn은 P0이 점유한 자원을 요구해야 한다.
<br/>

## 데드락(Deadlock)의 해결법
크게 아래의 3가지 해결법이 존재한다.

1. 데드락이 발생하지 않도록 **예방(prevention)** 하기
2. 데드락 발생 가능성을 인정하면서도 적절하게 **회피(avoidance)** 하기
3. 데드락 발생을 허용하지만 데드락을 **탐지(detection)**하여, 데드락에서 **회복(recovery)**하기

### 1. 교착 상태 예방 (Prevention)
> - 교착상태가 발생할 수 있는 요구조건을 만족시키지 않게 함으로써 교착상태를 방지
> - 위에 있는 교착상태 발생의 네가지 조건 중에서 어느 하나를 제거함으로써 수행
> - 자원 낭비가 가장 심한 기법

**No Mutual Esclusion (상호 배제 방지)**
모든 프로세스가 자원을 동시에 사용할 수 있도록 하는 방법이다. 하지만 이는 자원의 일관성을 해칠 수 있는 문제를 초래해 멀티프로그래밍을 포기하겠다는 말으로 현실적으로 말이 안되는 방식이다.

**No Hold and Wait (점유 및 대기 방지)**
프로세스가 필요한 모든 자원을 한 번에 요청하게 해서 데드락을 해결하는 방법이다. 프로세스는 자원을 점유한 상태에서 다른 자원을 요청할 수 없다. 이는 자원을 사용하기 전에 모든 필요한 자원을 확보하게 만들어 자원 낭비를 초래한다.

**Allow preemption (비선점 방지)**
선점 허용의 경우 데드락을 예방하는 가장 현실적인 방식이지만 강제로 자원을 회수하는 과정에서 데이터 일관성 문제가 발생할 수 있다. 또한 자원을 회수한 프로세스는 재시작하거나 복구해야 하므로 오버헤드가 발생할 수 있으며 회수된 자원을 다시 할당받기 위해 대기해야 하는 프로세스의 성능 저하가 발생할 수 있다.

**No Circular wait (순환 대기 방지)**
프로세스 간 자원을 순환 형태로 요청하지 못하도록 한다. 이는 모든 자원 요청을 선형 순서로 정렬하는데 우선순위 대로 처리하는 것이 가능은 하지만 현실적으로 구현이 복잡하고 비효율적인 매우 어려운 방식이다.

이렇게 미리 **Deadlock**을 방지하는 방식은 **효율성과 처리량을 감소**시키고, **Starvation**이 발생할 수 있다.

### 2. 교착 상태 회피 (avoidance)
> - 교착상태가 발생할 가능성을 배제하지 않고 **교착상태가 발생하면 적절히 피해나가는 방법**이다.
- 리소스 할당의 측면에서, 교착상태가 발생할 가능성이 있는 자원 할당(unsafe allocation)을 하지 않는다. (항상 **안전한 상태**(**safe state**)에서만 자원 요청을 허용하는 방법)
**Safe state** : safe sequence 가 존재하여 모든 프로세스가 정상적으로 종료할 수 있는 상태
**safe sequence** : 교착 상태를 발생 시키지 않고 자원을 할당하는 순서
- 주로 **은행원 알고리즘(Banker's Algorithm)**이 사용된다.


#### 은행원 알고리즘

은행원 알고리즘은 다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법

1. 프로세스 시작시 자신이 필요한 각 자원의 최대(Max) 개수를 미리 선언한다.
2. 각 프로세스에서 자원요청이 있을때 요청을 승인하면 시스템이 안전한 상태(safe state)로 유지되는 경우에만 자원을 할당한다.
3. 불안정 상태(unsafe state)가 예상되면 다른 프로세스가 끝날 때까지 대기한다.

<br/>

### 3. 교착 상태 탐지 (detection)
> - 교착 상태 탐지는 탐지 알고리즘을 사용하여 교착상태가 발생했는지 탐지
- 교착 상태가 탐지되었다면 복구 기법을 통해 교착상태를 복구
- 이 방식은 지속적으로 확인하는 작업이 필요하기 때문에 성능 저하가 발생

#### 교착 상태 탐지 알고리즘(wait-for graph)
![](https://velog.velcdn.com/images/ozziny/post/f8352e89-2ee7-4f56-acc2-654b5b71f35e/image.png)
<p align = "center">(a) 자원할당 그래프 , (b) 대기 그래프 </p>
자원 할당 그래프에서 자원을 제거 후 간선들을 결합하여 대기 그래프로 표현을 할 수 있다.

대기 그래프에서 Pi→Pj는 프로세스 Pi가 Pj프로세스가 보유하고 있는 자원을 기다리고 있음을 나타낸다.

대기 그래프에 주기(cycle)가 있다면 교착 상태를 의미

주기적으로 대기 그래프에 주기가 있는지 탐지 알고리즘을 호출하여 교착상태를 탐지 -> **추가적인 오버헤드 발생 **

#### 은행원 알고리즘(Banker's Algorithm)
각 자원 유형 마다 인스턴스가 여러게 있는 경우 은행원 알고리즘(Banker's Algorithm)을 사용하여 교착상태를 탐지한다.

교착상태 회피에서 사용하는 은행원 알고리즘과는 약간의 차이가 있다.

1. 각 프로세스의 자원 요청(Request) 개수를 사용합니다.
2. 현재 상태가 안전 상태(safe state)인지 확인합니다.
3. 불안정 상태(unsafe state)라면 교착상태라고 판단합니다.

<br/>

### 4. 교착 상태 회복 (recovery)
> - 교착 상태가 발생했다면 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 복구를 함.
- 복구 방식에는 크게 두 가지가 있다.

#### 프로세스 종료
교착상태에 있는 프로세스를 종료하는 방식으로 프로세스 종료에는 두가지 방법이 있다.

1. 교착 상태의 프로세스를 모두 중지
2. 교착 상태가 제거될 때까지 한 프로세스씩 중지

#### 자원 선점
교착 상태에 있는 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하여 해당 프로세스를 일시 정지시키는 방법이다.

자원 선점에 있어서 다음 사항들을 고려해야 한다.

1. **희생자 선택 (selection of a victim)**
최소의 피해를 줄 수 있는 프로세스를 선택합니다.

2. **롤백(rollback)**
선점 된 **프로세스를 문제 없던 이전 상태로 롤백**해야한다.
보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 방법이다.

3. **기아 상태(starvation)**
한 프로세스가 계속 선점되어 **기아상태가 되는 것을 방지**해야 한다.
(한 가지 방법은 우선 순위를 사용하여 선점 될때마다 프로세스 우선순위를 높이는 것이다.
