# [OS] CPU 스케줄링

## 1.1 스케줄링의 단계

수행 단계에 따라, 장기 스케줄링 / 중기 스케줄링 / 단기 스케줄링으로 나뉨
<br/>
- 장기 스케줄링: 요청된 일을 프로세스로 만들어 시스템에 알려진 일거리로 추가하느냐를 결정<br/>
(수행횟수 적고, 대부분 FIFO 방식)
- 중기 스케줄링: 보유 상태의 프로세스들 중 어느 프로세스에 메모리를 할당해줄 것인지 결정
- 단기 스케줄링: 준비 상태에 있는 프로세스들 중 어느 프로세스에게 CPU를 할당할지 결정<br/>
(by. 프로세스 스케줄러 or 디스패처(Dispatcher)에 의해 수행)
<br/>

**Dispatcher**

- CPU의 제어권을 CPU Scheduler에 의해 선택된 프로세스에게 넘긴다.
- 이 과정을 **Context Switch**라고 한다.
<br/>

**프로세스의 상태**

**: 준비(Ready), 대기(Blocked), 실행(Running), 종료(Terminate)**

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593738/06cb2817-ca0a-4d95-989e-1f138c34adcd)


## 1.2 스케줄링의 목적과 기준

### 스케줄링의 목적

CPU를 할당받을 프로세스를 잘 골라 실행시켜줌으로써 전체적으로 시스템의 성능을 높이고자 함

<br/>

### 무엇을 보고 시스템의 성능을 평가할까?

[ 사용자 관점 ]

- 응답 시간(Response Time): 프로세스 요청에 대해 시스템이 최초로 출력 시작할 때까지 걸린 시간
- 반환 시간(Turn-around Time, 소요 시간): 요청으로부터 결과를 돌려받는 데까지 걸린 시간
- 예측가능성(Predictability): 요청한 일이 얼마 후쯤에 완료될 수 있을지
<br/>

[ 시스템 관점 ]

- 처리량(Throughput) : 단위 시간에 완료된 프로세스의 개수
- 활용도(Utilization) : 주어진 시간 동안 특정 자원이 실제로 가동된 시간의 비율
<br/>

하지만, 모든 지표를 만족하는 것은 불가능하다.

→ 따라서, 시스템을 사용하는 환경과 목적에 맞는 지표에 치중해서 스케줄링을 해야 함

<br/>

## 1.3 스케줄링 기법

현재 실행 중인 프로세스로부터 다른 프로세스로 CPU를 넘겨줄 때, 기다리는 여러 프로세스들 중 어떤 프로세스로 넘겨줄지에 대한 방식이나 기준이 필요.
<br/>

### When? 스케줄링 가동

- 실행(Running) → 대기(Blocked)  // ex) 입출력  **`비선점`**
- 실행(Running) → 준비(Ready)  // ex) 시간 종료 (인터럽트) **`선점`**
- 대기(Blocked) → 준비(Ready)   // ex) 입출력 종료 **`선점`**
- 종료(Terminated)   **`비선점`**

<hr/>

- 비선점(Nonpreemptive) || 선점(Preemptive) (=빼앗음)

<br/>


## 스케줄링 기법

### FIFO(First Come First Out)

- 먼저 도착한 프로세스에게 CPU를 먼저 할당한다.
- 평균 응답 시간↑
    - 프로세스가 CPU를 독점하기에, 아주 긴 프로세스가 실행된 경우 뒤의 프로세스는 오래 기다려야 함
- 예측가능성↑, 공평성↑
    - 준비 상태 프로세스들의 개수와 크기를 짐작할 수 있다면, 프로세스의 실행을 예측할 수 있고 도착 순서만이 실행 순서를 결정 짓기에 공평하다고 할 수 있음
- 가장 단순한 형태로, 실제 시스템에서 바로 사용되기는 어려우나(매우 비효율적 방식), 다른 스케줄링 기법의 보조 역할(차선책)으로서 활용할 수 있다.

---

- Convoy effect : 긴 시간의 프로세스 뒤에 짧은 시간의 프로세스가 위치하는 현상 (매우 오래 기다려야 함)

<br/>

### SPN(Shortest Process Next)

- 가장 짧은 (CPU 요구량이 가장 적은) 프로세스를 먼저 실행한다.
- NonPreemptive
    - CPU를 잡으면 해당 순차의 CPU burst가 완료될 때까지 CPU를 선점당하지 않는다.
- 평균 응답 시간↓, 처리량↑
- 주어진 프로세스들에 대해 Minimum Average Waiting Time을 보장한다.
- 무한대기 현상 발생 (Starvation)
    - 실행 시간이 긴 프로세스는 CPU를 할당받지 못하고 계속 대기
- 다음 번 CPU burst time을 예측하기 어려움
    - 해당 순차에서 다음 번 CPU burst time을 미리 알고 스케줄링 하는 것은 불가능하다.
    - 미리 알 수 없기에, 그 대안으로 과거 CPU burst time들을 이용해 추정한 값을 사용할 수 있다.

<br/>

### SRT(Shortest Remaining Time)

- SPN을 선점 방식으로 운영하는 것
- Preemptive
    - 현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착 시 CPU를 선점당한다.
    - SRTF (Shortest-Remaining-Time-First)라고도 부른다.
- SPN의 단점과 함께, 완료까지 남은 실행시간의 계산, 실행시간이 짧은 프로세스가 자주 도착할 경우의 잦은 선점으로 인한 **문맥교환**의 부담이 존재

<br/>

### *Quiz. SRT에서 문맥 교환을 덜 할 수 있는 방법?

예시 1) 조금만 있으면 완료되는 프로세스.. 근데 더 짧은 프로세스가 들어오는 상황

예시 2) 남은 시간이 길지만, 짧은 게 없어서 CPU를 받은 프로세스.. 근데 얼마 지나지 않아, 마찬가지로 길지만 나보다는 짧은 프로세스가 들어오는 상황

→ SRT 기준으로는 두 경우 모두 문맥교환을 해야한다.

<br/>

### HRRN(Highest Response Ratio Next)

- SPN과 SRT의 약점인 수행 시간이 긴 프로세스의 무한 대기 현상을 방지하기 위한 기법
- 응답률(Response Ratio)가 가장 높은 프로세스에게 우선 순위를 줌 (비선점 방식)
    
    응답률 = (대기시간 +  CPU 요구량) / CPU 요구량
    
    - 기다리는 시간이 길어질수록 우선 순위가 높아짐

<br/>

### 라운드 로빈(Round-Robin)

- FIFO를 기반으로 하되, 각 프로세스는 한 번에 쓸 수 있는 CPU 시간 크기, 즉 시간할당량(Time Quantum)을 가진다.
- 시간할당량이 지나면, 시간 종료 인터럽트에 의해 CPU를 뺏김 **(선점 방식)**
- 선점당한 후 Ready Queue의 제일 뒤에 가서 다시 줄을 선다.

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593738/c46b0f5b-a746-4343-b37d-fc4f75c3dce4)

<br/>

### 다단계 큐(Multi-level Queue)

- 우선순위의 개수만큼 큐가 필요
    - 같은 우선순위 값을 가지는 프로세스들
    - 서로 다른 우선순위의 프로세스를 구별하고 관리
- 우선순위가 낮은 하위 단계 큐의 작업은 실행 중이더라도 상위 단계 큐에 프로세스가 도착하면 CPU를 뺏김 **(선점 방식)**
- 정적 우선 순위이므로 큐들 간에 프로세스 이동이 불가능

```
✅ 우선적으로 처리되어야 하는 프로세스 그룹으로 나누고 각 그룹에 따라서 처리 할 큐를 여러 개 두어 사용하는 방식이다.
하지만 우선순위가 높은 상위 큐 프로세스가 계속해서 들어온다면, 하위 큐 프로세스의 작업을 할 수 없는 단점이 있다.
```

<br/>

### 다단계 피드백 큐(Multi-level Feedback Queue, MFQ)

- CPU 요구량을 몰라도 짧은 프로세스들에게 유리하면서 입출력 프로세스를 우대할 수 있는 스케줄링 기법
- 동적 우선순위 기반 **(선점 방식)**
    - Multi-level Queue와 달리 프로세스가 다른 Ready Queue를 옮겨다니는 것이 가능하다.
- Aging과 같은 방식을 통해 우선순위가 낮은 큐도 실행될 수 있도록 할 수 있다.

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593738/823eb394-f01a-4473-abdd-c63808950578)


```
✅ CPU를 사용하고 난 프로세스는 우선순위가 낮아지는 방식이다.
즉, CPU를 사용하고 난 프로세스는 원래의 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어가게 된다.
또한 피드백 큐는 큐 사이로 프로세스들의 이동이 가능하기 때문에 aging 기법을 활용해서
오랜시간동안 할당 받지 못한 프로세스가 있다면 상위 큐로 격상시키면서 우선순위를 올려줄 수 있다.
```

---

### Quiz

- **CPU 스케줄링이 무엇인가요?**
    
    CPU 하나는 동시에 여러개의 프로세스를 처리할 수 없기 때문에, 한 순간에 어떤 프로세스가 CPU를 사용할 수 있게 하는지 결정하는 정책입니다. CPU 스케줄링은 비선점 스케줄링과 선점 스케줄링을 나뉘는데 FCFS, SJF, 라운드 로빈, 다단계 큐 등이 있습니다. 
    
- **기아(starvation)이란 무엇인가요?**
    
    특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태입니다. 예를 들어, 선점형 스케줄링 방식에서 SRTF  라는 것이 있습니다. 해당 스케줄링 방식은  작업량이 가장 적은 사람을 먼저 처리하는 스케줄링 방식이지만 작업량이 낮은 프로세스가 계속해서 들어온다면 작업량이 많은 프로세스는 평생 CPU의 할당을 받지 못할 수 있습니다. 이러한 현상을 기아 현상이라고 일컬으며 에이징 기법을 통해 해결할 수 있습니다. 
    
- **에이징(aging)은 무엇인가요?**
    
    에이징은 자원 스케줄링 시스템에서 기아를 방지하기 위해 사용되는 기술입니다. 우선순위가 높은 프로세스가 계속 들어와서 CPU의 할당을 받게 된다면 이전에 우선순위가 낮은 프로세스들은 무한정기다리게 되는 상황이 생길 수 있습니다. 이때 기다린 시간에 비례하여 일정 시간이 지나면 우선순위를 한 단계씩 높여서 자원을 할당 받을 수 있도록 하는 기법입니다. 
    
- **Context Switching이란?**
    
    프로세스 상태를 변경하는 것을 말합니다. 스케줄러에 의해 실행 중인 코드, 자원 등을 저장하고 현재 상태를 대기 상태로 전환한 뒤 다른 프로세스를 실행시키는 과정입니다.
