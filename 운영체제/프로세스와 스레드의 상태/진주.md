# 프로세스와 스레드의 상태

## 1 프로세스란 무엇일까?

프로세스는 일반적으로 수행 **중인 프로그램**이라고 말한다. 하지만 주기억장치에 적재되어있는 프로세스 중 CPU에 할당되어 실행되는 것은 하나의 프로세스 뿐이다.(CPU가 1개인 경우로 가정)

그래서 프로세스를 **주기억장치에 적재되어 커널 영역에 PCB를 부여받은 프로그램**이라고 표현하기도 한다. 프로세스는 아래 나오는 내용과 같이 '실행' 상태를 포함하여 여러 상태 변화를 거치게 된다.

<br/>
 
## 1.1 프로세스 제어 블록(Process Control Block, PCB)

- 하나의 프로세스가 시스템에 존재할 때의 모습
- 프로세스에 대한 모든 것을 표현하는 것이 PCB이다.
- 운영체제가 프로세스를 관리한다는 것은 PCB의 생성, 수정, 리스트 연결, 지우는 등의 행위이다.
- PCB 작업은 매우 빈번한 일이라 PCB는 메모리에 저장시킨다.

<br/>

## 1.2 프로세스 상태(Proccess State)와 변화

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593738/32bc9e5c-1ea7-4bc3-bf5c-55beb75ac7f1)

### 생성 상태 (Created)

→ 사용자가 요청한 작업이 커널에 등록되고 PCB가 만들어져 프로세스가 만들어진 다음 준비나 보류 준비 상태로 되기 위해 잠시 거치는 상태

- 운영체제는 프로세스를 생성한 후 메모리 공간을 검사하여 충분한 공간이 있으면 메모리를 할당하면서 준비 상태로 바꾸어주고, 그렇지 못할 경우 보류 준비 상태로 만든다.

<br/>
 
### 준비 상태 (Ready)

→ CPU를 할당받기 위해 기다리고 있는 상태. 즉, CPU만 주어지면 바로 실행할 준비가 되어있는 상태

- 메모리에 적재
- 큐(또는 리스트)가 사용
- **스케줄링**?
    - 준비 상태의 프로세스들은 순서에 따라 CPU를 할당받으면 실행 상태가 되는데, 이때 순서를 정하는 것을 **CPU 스케줄링**이라 함

<br/>
 
### 실행 상태 (Running)

→ CPU를 할당받아 실행 중인 상태

- 디스패치(Dispatch)
    - CPU를 할당하는 것
- 단일 CPU : 하나의 프로세스만이 실행상태
여러 CPU : 동시에 여러 프로세스가 실행상태 가능 (다중처리)
- 실행 상태의 프로세스는 CPU 스케줄리 정책에 의해 CPU를 뺏길 수 있다.
(실행 → 준비 상태 변경)
- 예.
    - 시간 종료(Timeout): 시간 할당량(Time Quantum)이 소진되어 뺏길 때
    (실행→ **준비**)
    - 입출력 (실행 → **대기**)

<br/>
 
### 대기 상태 (Blocked)

→ 프로세스가 실행되다가 입출력 처리를 요청하거나, 바로 확보될 수 없는 자원을 요청하면 CPU를 양도하고 요청한 일이 완료되기를 기다리면서 대기하는 상태

- 큐(또는 리스트) 사용
- 요청한 일이 완료되면 다시 실행 차례를 기다리기 위해 준비 상태로 바뀌면서 준비 큐에 들어감

<br/>
 
### 종료 상태 (Terminate)

→ 프로세스가 종료될 때 아주 잠시 거치는 상태

- 할당되었던 모든 자원들이 회수되고 PCB만 커널에 남아있는 상태
- 운영체제가 시스템에 남겨져있는 이 프로세스의 흔적들을 최종 정리 후 PCB를 삭제하면 프로세스가 완전히 사라짐

<br/>
 
---
## Quiz!

### 입출력이 끝나면 바로 일을 계속해 나갈 수 있는데, 왜 대기 상태에서 실행상태로 가도록 하지 않을까?

<br/>

---

### *활성 상태 (Active State)

: 준비, 실행, 대기 상태

- 실행될 프로그램과 데이터 등을 위해 메모리 공간의 일정량을 부여받음

### *보류 상태 (Suspended State)

- 메모리가 부족하거나 다른 이유에 의해 활성 상태의 프로세스로부터 메모리를 회수함
- 스와핑(Swapping)
    - Swapped in: 프로세스가 메모리 공간을 뺏기고 디스크로 나가는 것
    - Swapped out: 나중에 다시 들어오는 것

<br/><br/>

### 보류 준비 상태 (Suspended Ready)

→ 생성된 프로세스가 바로 메모리를 받지 못하거나 준비 또는 실행 상태에서 메모리를 잃게 될 때를 위해 필요

- 주기억장치에 여유가 생기거나, 준비 상태의 프로세스가 전혀 없을 때(CPU를 할 일 없이 놔두지 않기 위해) 대기 상태의 프로세스를 보류 대기 상태로 만들고 후에 준비 상태로 바뀜 (Resume)

<br/>

### 보류 대기 상태 (Suspended Blocked)

→ 대기 상태에서 메모리 공간을 잃은 상태

- 입출력이나 기다리던 사건의 종료 시 보류 준비 상태로 바뀜


<br/>

---

## Quiz!
 
### 보류 상태는 메모리 공간 확보 외에 또 어떤 경우에 필요할까?

<br/>
 
- 실행되는 프로세스의 현재 결과가 바라던 것이 아닌 오류가 보일 때
- 시스템을 위해 가할 수 있는 수상한 행동을 보일 때
- 주기적인 일이라서 다음 주기의 실행 때까지 메모리를 회수해도 문제되지 않을 때 등

<br/>

---

<br/>
<br/>

## 2 스레드란 무엇일까?

프로세스는 자원과 제어의 특성이 존재한다.

⇒ 여기서 제어만 분리한 실행 단위가 스레드(Thread)!

- 프로세스 1개는 스레드 1개 이상으로 나눌 수 있음
- 보통 다른 프로시저를 호출하고 다른 실행을 기록
    
    → 그러므로 별도의 스택이 필요하고, 프로그램 카운터(PC)가 독립적이라서 같은 프로세스의 스레드들이 동시에 코드의 동일한 부분이나 다른 부분을 실행할 수 있다.
    

<br/>

## 2.1 스레드의 상태

프로세스와 마찬가지로 스레드 역시 실행, 준비, 대기와 같은 상태를 가진다. 다만 보류는 프로세스 레벨의 개념이므로 스레드에서는 필요 없는 상태이다. 

스레드는 프로세서를 함께 사용하고 **항상 하나만 실행**한다. 또, **한 프로세스에 있는 스레드는 순차적으로 실행**하고, 해당 스레드의 정보를 저장하는 레지스터와 스택이 있다.

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593738/985e3e5f-da12-4fad-b208-61d62554e2a8)

- 보통 프로세스를 생성하면 해당 프로세스의 스레드도 생성한다.
    - 이 때 운영체제는 프로세스가 스택과 레지스터를 제공하므로 프로세스와의 공유자원을 초기화할 필요가 없다.
    - ⇒ 프로세스의 생성과 종료보다 오버헤드가 훨씬 적음
- [장점] 스레드 1개가 대기 상태로 변할 때 전체 프로세스를 대기 상태로 바꾸지 않는다!
    - 실행 상태의 스레드가 대기 상태가 되면 다른 스레드를 실행할 수 있음
- but, 스레드 1개가 다른 스레드의 스택을 읽거나 쓸 수 있어 프로세스와 같이 독립적이지는 않다.
    - 프로세스 하나에 있는 전체 스레드는 프로세스의 모든 주소에 접근할 수 있음

<br/>

### Quiz

- 어떤 프로세스가 한 번의 시간 종료 인터럽트를 겪고 그 후 한 번의 입출력을 한 후 완료된다고 했을 때 상태가 변화하는 과정을 설명하세요. (created부터~)
