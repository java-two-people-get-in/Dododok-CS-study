## 디스크 관리(Disk Management)
디스크는 가장 많이 사용하는 보조기억장치 중 하나로 헤드(head)가 임의의 섹터(sector)를 랜덤하게 참조할 수 있고 빠르게 데이터를 읽어올 수 있으며, 주기억장치(RAM)보다 많은 양의 데이터를 저장할 수 있다

다중 프로그래밍 환경에서는 여러 프로세스가 메인 메모리에서 실행 중에 있는데, 이러한 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 수 있다. 이와 같은 요청이 오면 디스크 역시 CPU와 같이 **디스크 큐(dist queue)**에서 요청을 저장해두고 이를 처리해야 한다.

여기서 컴퓨터의 성능을 위해 여러 요청들을 효율적으로 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 이러한 방법들을 **디스크 스케줄링 알고리즘**이라 한다.

## 디스크 접근 시간
**탐색시간(Seek time)** : 현 위치에서 특정 실린더(트랙)로 디스크 헤드가 이동하는 데 소용되는 시간
**회전 지연시간(Rotation delay time)** : 가고자 하는 섹터가 디스크 헤드까지 도달하는 데 걸리는 시간
**전송시간(Trandsfer time)** : 데이터를 전송하는 데 걸리는 시간


이 중에서 **seek time(head를 움직이는 시간)**이 가장 크다.

## 디스크 스케줄링 

### FCFS(First Come First Served)
![](https://velog.velcdn.com/images/ozziny/post/3d56a152-5050-4eb2-a67f-b6174c89fa02/image.png)

큐에 가장 먼저 **요청이 온 순서**대로 서비스한다.
- 장점 : 알고리즘이 다른 기법보다 단순하며, 공평하게 요청을 처리한다.
- 단점 : 비용이 많이 발생되어, 비효율적임...

큐 = 105, 180, 40, 120, 10, 125, 65, 70 / 초기의 헤드가 트랙 50에 있을 경우

**헤드가 움직인 총 거리**
(105 - 50) + (180 - 105) + (180 - 40) + (120 - 40) + (120 - 10) + (125 - 10) + (125 - 65) + (70 - 65) = 640

위 그림의 결과를 본 것처럼 큐에 들어온 순서가 큰 값, 작은 값이 반복한다면 헤드가 움직이는 거리가 매우 커진다.



### SSTF(Shortest Seek Time First)
![](https://velog.velcdn.com/images/ozziny/post/12e3f680-bc73-4cdd-97ba-875a1e519880/image.png)

현재 헤드에서 **가장 가까운 트랙의 요청을 먼저 처리**한다. 즉 현재 헤드셋을 처리하고, 다음 요청 중에 이동거리가 가장 적은거리에 있는 트랙을 처리한다.

- 장점 : Seek Time 이 적다. 즉 트랙을 찾는 시간을 최소화 할 수 있고, **처리량(Throughput)을 극대화** 할 수 있다.
- 단점 : 안쪽 및 바깥쪽에 있는 요청들은 기아 현상이 발생할 수 있다. 도한, **응답 시간 편차**가 크다.

### SCAN
![](https://velog.velcdn.com/images/ozziny/post/4d34a44e-9338-4aed-80c5-04510cc67c0e/image.png)

헤드셋의 진행방향에 있는 요청을 처리하고, 다시 반대 방향으로 틀어 반대방향에 있는 요청들을 처리한다. 마치 엘레베이터가 동작하는 원리가 같아서 **엘레베이터 기법**이라고도 한다. 

- 장점 : SSTF의 바깥쪽 트랙의 기아가능성을 제거할 수 있고, 응답시간의 편차를 줄일 수 있다.
- 단점 : 양 쪽 끝 트랙 가운데 위치한 트랙보다 대기 시간이 길어진다. 엘레베이터로 비유하자면, 맨 꼭대기 층이 중간층보다 응답시간이 늦어질 수 있다는 뜻.

### C-SCAN
![](https://velog.velcdn.com/images/ozziny/post/c96f3c6e-82c1-4e54-8b99-f5fe9c898843/image.png)

**항상 한쪽 방향에서 반대방향으로 진행하며 트랙의 요청을 처리**한다. 즉 바깥쪽에서 안쪽으로 진행하며 요청을 처리한다. SCAN의 변형된 형태로 조금더 시간을 균등하게 배분할 수 있다.

- 장점 : 응답시간의 편차가 매우 적음, SCAN보다 시간균등성이 좋음
- 단점 : 안쪽이나, 바깥쪽으로 처리할 요청이 없어도 헤드셋이 끝까지 이동하기 때문에 비효율적

### LOOK, C-LOOK
![](https://velog.velcdn.com/images/ozziny/post/e0e801ed-e186-4451-88fb-b9065741efd2/image.png)

**LOOK 과 C-LOOK** 은 **SCAN과 C-SCAN을 보완**하기 위한 스케쥴링 기법이다. SCAN과 C-SCAN의 비효율적인 부분은 끝단에 요청이 없어도 끝단까지 도달하고야만다는 것이다. 따라서 요청이 진행방향에서 더이상 없다면, 끝단까지 가지않고 반대방향으로 가던가(SCAN), 다시 같은 같은 방향으로 진행(C-SAN)하게 한다.



- 장점 : 불필요한 헤드 이동시간을 제거
- 단점 : 끝단까지 가야할지 말아야할지 판단하는데 있어서 오버헤드 발생