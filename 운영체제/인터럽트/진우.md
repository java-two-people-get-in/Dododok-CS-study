# [OS] 인터럽트

## 1. 인터럽트?

**인터럽트**란, 프로세스 실행 도중 예기치 않은 상황이 발생할 때 발생한 상황을 처리한 후 **실행 중인 작업으로 복귀**하는 것을 말한다.( = 복귀하라는 signal을 인터럽트라고 한다.)

> 인터럽트는, **신호(Signal)**이다. HW, SW등에서 인터럽트라는 신호를 발생시킨 경우, CPU에서 그것을 감지하여 인터럽트 핸들링을 진행하는 것이다. 
> 

**Q. 인터럽트가 필요한 이유?**

A. 대부분의 I/O 장치들의 처리 속도가 CPU에 비해 현저히 느리기 때문!<br/><br/>



### 1.1. 인터럽트 처리 과정

<img width="743" alt="image" src="https://github.com/java-two-people-get-in/Dododok-CS-study/assets/77064618/361f6fd5-31bf-42f1-823e-913e8995d358">

- 1, 2, 3번은 CPU에서 작업하는, 유저 프로그램의 처리 과정이다.(속도가 빠름)
- 4, 5번은 입출력 장치 내부의 컨트롤러가 작업하는 과정이다. (속도가 매우 느림)

**왼쪽) 인터럽트를 사용하지 않았을 때의 처리 방법이다.**

인터럽트가 존재하지 않는다면, 1 - 4 - 5 - 2 - 3 의 순서로 프로그램이 동작한다.
입출력장치에서 입출력이 완료될 때 까지, CPU는 기다리게 되므로 효율이 떨어진다.

**오른쪽) 인터럽트를 사용했을 때의 처리 방법이다.**

1. 1을 실행한 뒤, 입출력 작업이 필요한 코드를 접한다. 
2. 입출력장치에게 4번을 실행하게 한 뒤, **입출력이 끝났을 때 신호(I/O 인터럽트)**를 보내달라고 요청하고 2 작업을 실시한다.
3. 2a시점에서 입출력장치로부터 인터럽트가 도착하고, 인터럽트 처리를 위한 인터럽트 핸들러를 실행한다.**(컨텍스트 스위칭)**
참고로, 인터럽트 핸들러는 OS의 프로그램이다.
4. 인터럽트 핸들링이 끝난 후, 3번 작업을 이어서 진행한다.**(컨텍스트 스위칭)**

    <br/>


### 1.2. 인터럽트 핸들러( = ISR, Interrupt Service Routine)

**인터럽트 핸들링**은, 인터럽트가 발생했을 때 OS에서 적절하게 처리하는 과정을 말한다.

인터럽트 핸들러 SW이며, 프로그램이다. 따라서 운영체제가 사용하는 커널 메모리에 적재되어 있다. 

인터럽트의 종류에 따른 핸들러의 메모리 주소를 가리키고 있는 **인터럽트 벡터**라는 자료구조를 사용하여 찾는다.

> **컨텍스트 스위칭과 PCB**
>
> 프로세스는 **코드, 데이터, 스택, 힙, PCB**로 이루어져 있다고 했었다. 
> 
> 인터럽트 신호가 발생한 것을 알게되면, 현재 실행중인 프로세스에 대한 정보를 **PCB**에 모두 저장한다. 그리고 인터럽트 핸들링을 마치고, **PCB**에 저장된 값을 확인하여 이어서 프로그램을 실행하는 것이다.
> 
<br/><br/>


## 2. 인터럽트의 종류 - HW 인터럽트

**외부 인터럽트(HW 인터럽트)**, **내부 인터럽트(SW 인터럽트)**로 분류 가능하다.<br/>


### 2.1. Timer 인터럽트

CPU는 time-slice만큼 작업을 수행한 뒤, CPU 스케줄러에 따라서 다른 프로세스의 작업을 수행하게 된다.( =컨텍스트 스위칭)

일정 시간이 지났음을 체크하는 **timer**라는 장치에 의해 인터럽트가 발동된다.<br/>


### 2.2. I/O 인터럽트

HDD, SDD, 마우스, 키보드와 같은 입출력장치에 의해 발생하는 인터럽트이다.
정확히는 입출력 장치 내부의 컨트롤러가 인터럽트를 발생시킨다.<br/>


### 2.3. hardware failure 인터럽트

하드웨어적인 결함이나 문제가 발생했을 경우, 해당 하드웨어에서 인터럽트를 발생시킨다.<br/>

<br/><br/>


## 3. 인터럽트의 종류 - SW 인터럽트

### 3.1. Program 인터럽트(SW 인터럽트)

하드웨어 장치에서 발생시키는 인터럽트가 아니라, 메모리 내에 존재하는 프로그램에 의해 발생되는 인터럽트이다.
Ex) overflow, underflow, devided By 0,  잘못된 메모리 접근, **Memory Fault(실행해야하는 코드가 메모리에 존재하지 않는 page fault)** 등 <br/>


### 3.2.SVC(Supervisor Call) 인터럽트

입출력을 하는 과정은, `scanf` `printf`가 아니라 `read`와 `write` 라는 **System call**이다. 이 명령어들은 OS에서만 접근 가능하기 때문에 커널모드로 전환하는 인터럽트이다.<br/>


> **CPU 실헹 모드**

User mode : cpu가 유저프로그램을 실행중. 권한과 자원의 수준이 낮음.
Kernel mode  cpu가 os프로그램을 실행중. 모든 권한 부여
>
