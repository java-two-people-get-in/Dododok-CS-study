# [OS] 프로세스 동기화

## 0. 사전지식
동기화 : 협렵 프로세스 간의 실행 순서를 정해주는 메커니즘

## 1. 프로세스 동기화란 무엇인지 설명해주세요.
프로세스가 공유하는 자원의 일관성을 유지하는 것으로, 프로세스가 통신을 하거나 임계구역 문제를 해결하기 위해 서로 신호를 주고받아 작업 순서를 정하는 것

## 2. 동기화가 필요한 이유가 무엇인지 설명해주세요
Race Condition(경쟁 상태) : 여러 프로세스들이 동시에 공유 자원에 접근하려할 때, 어떤 순서로 데이터에 접근하느냐에 따라 결과 값이 달라질 수 있는 상황
이러한 경쟁 상태에서 프로세스간의 공유 자원 접근 순서를 정해주는 동기화를 통해 데이터 불일치 문제와 데이터 일관성을 유지하기 위해서 필요함.

## 3. 임계구역(Critical Section)이 무엇인지 설명해주세요
임계구역 : 여러 프로세스(또는 스레드)가 자원을 공유하는 상황에서 하나의 프로세스(스레드)만 접근할 수 있도록 제한해둔 영역, 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 코드 영역

### 3-1. 임계구역을 해결하기 위한 조건을 설명해주세요
1. 상호 배제(mutual exclusion) : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다
2. 한정 대기(bounded waiting) : 어떤 프로세스도 무한 대기하지 않아야 한다. 즉, 특정 프로세스가 임계구역에 진입하지 못하면 안 된다.
3. 진행의 융통성(progress) : 임계구역에 프로세스가 없다면 어떠한 프로세스라도 들어가서 자원을 활용할 수 있다. 즉, 두 프로세스가 자원을 번갈아 쓴다고 가정할 때 한 쪽에서 자원을 안쓰고 있다고해서 다른 한 쪽 프로세스가 자원을 쓰고싶어도 자신의 turn이 아니라고 기다리는 것은 효율적이지 못하다는 것이다.

## 4. 임계구역 해결 방법을 설명해주세요
critical section 문제를 해결하는 단순한 방법은 Lock을 사용하는 것이다.
즉, 한 프로세스가 critical section에 들어간다면 lock을 걸어놓아 다른 프로세스가 들어오지 못하게 한 후, 프로세스가 critical section에서 빠져나오게 되면 lock을 해제하고 동시에 동기화 신호를 보내는 것이다.
- 
### 4-1. 하드웨어적인 해결 방법
- Test_and_Set(검사와 지정) 코드 사용 : 메모리에서 데이터를 읽으면서 쓰는 것까지 하나의 명령어로 동시에 수행이 가능하도록 하드웨어적인 지원을 받는 것

![스크린샷 2024-07-04 025807](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/4b00af6c-2f77-4229-9d9c-796fb5cfe798)

lock=true가 작동하기 직전에 timeout이 걸려 ready 상태로 돌아가면 상호 배제에 위배되는 문제가 발생.
이를 해결하기 위해 Test_and_Set(검사와 지정)이라는 코드로 하드웨어 지원을 받아 while(lock == true);문과 lock=true;문을 한꺼번에 실행한다. 검사와 지정 코드를 이용하면 명령어 실행 중간에 타임아웃이 걸려 임계구역을 보호하지 못하는 문제가 발생하지 않음.

하지만 busy waiting(상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것)을 사용하므로 자원 낭비가 생김

### 4-2. 알고리즘 적용
- 피터슨 알고리즘
![피터슨알고리즘](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/9122be19-4f79-4652-86bc-e70330107f68)
turn이라는 개념을 활용하여, lock을 걸면서 다음의 상대에게 turn을 넘겨주는 것이다.
ex) 프로세스 p2가 잠금을 설정하지 않았거나 잠금을 설정했더라도 turn=1로 바꾸면 프로세스 P1은 임계구역에 진입해 작업을 마친 후 잠금을 해제하고 임계구역을 빠져나옴
---
- 데커 알고리즘
![데커 알고리즘](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/0768c92f-8cd6-475d-8ee0-ee2f93c29cf4)
1. 프로세스 P1은 우선 잠금을 건다. (lock1 = true)
2. 프로세스 p2의 잠금이 걸렸는지 확인한다(while(lock2 == true))
3. 만약 프로세스 p2도 잠감을 걸었다면 누가 먼저인지 확인한다.( if(turn == 2)) 만약 프로세스 p1의 차례라면(trun = 1) 임계구역으로 진입한다. 만약 프로세스 p2의 차례라면 (trun =2) 4로 이동한다.
4. 프로세스 p1은 잠금을 풀고(lock1 = false) 프로세스 p2가 작업을 마칠 때까지 기다린다. (while(turn==2)) 프로세스 p2가 작업을 마치면 잠금을 걸고(lock1=true) 임계구역으로 진입한다.

피터슨과 데커 알고리즘은 임계구역 해결의 세가지 조건을 모두 만족하지만 프로세스가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다. 또한, busy wating을 사용하므로 자원 낭비도 일어난다.

---
- 세마포어(semaphore)
임계 구역에 진입하기 전에 사용중이라는 표시를 한 후 임계구역으로 들어간다. 이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다. 프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임게구역을 사용하라는 동기화 신호를 보낸다.
<br>
위의 알고리즘과 다른 점 : 임계구역이 lock 되어 있는지 직접 점검하거나 busy waiting을 하거나, 다른 프로세스에 동기화 메시지를 보낼 필요가 없다.

![세마포어 알고리즘](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/da3b2182-b1db-46da-a2bf-aeec7fee0b95)
1. Semaphore(n) : 전역 변수 RS를 n으로 초기화한다. RS에는 현재 사용 가능한 자원의 수가 저장된다.
2. P() : 잠금을 수행하는 코드로 RS가 0보다 크면(사용 가능한 자원이 있다면) 1만큼 감소시키고 임계구역에 진입한다. 만약 RS가 0보다 작으면(사용할 수 있는 자원이 없으면) 0보다 커질 때까지 기다린다.
3. V() : 잠금 해와 동기화를 같이 수행하는 코드로, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에 임계구역에 진입해도 좋다는 wake_up 신호를 보낸다.
4. 잠금이 해제되기를 기다리는 포로세스는 세마포어 큐에 저장되어 있다가 wake_up 신호를 받으면 큐에서 나와 임계구역에 진입한다. -> 따라서, busy waiting을 하는 프로세스가 없음
```
<세마포어 코드> 
procedure P(S)  
    S := S-1  --> s값 감소
    while S>0 do wait  --> S 값이 0보다 작으면 기다려야 함(wait)
end P

// --- 임계 구역 ---

procedure V(S)
    S := S+1   --> S값 증가
end V
```
<br>
그러나 세마포어의 P(),V() 내부 코드가 실행되는 도중에 문맥 교환이 발생하면 한정 대기와 상호 배제 조건을 보장하지 못한다. 따라서 내부 코드는 Test_and_Set을 사용해 분리 실행되지 않고 완전히 실행되도록 해야한다.

---
- 뮤텍스(Mutex)
<br>
세마포어의 공유자원(RS)이 1일 때를 말한다. 따라서 뮤텍스와 세마포어는 구동 방법, 원리가 모두 같다.

![뮤텍스 알고리즘](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/861d2bba-ed08-4c79-9fa8-5e136b15d1a6)
1. 프로세스 P1이 먼저 wait(mutex)을 호출하여 mutex = 0으로 만들고 임계 구역에 진입한다.
2. 프로세스 P2가 wait(mutex)을 호출하지만 mutex는 이미 0이므로 임계 구역에 진입하지 못하고 block된다. mutex queue에 들어간다.
3. 프로세스 P3가 wait(mutex)을 호출하지만 mutex는 이미 0이므로 임계 구역에 진입하지 못하고 block된다. mutex queue에 들어간다.
4. 프로세스 P1이 임계구역의 일을 마치고 signal(mutex)을 호출하여 mutex = 1로 만들고 mutex queue에서 block 상태인 프로세스 P2를 깨운다.
5. 프로세스 P2는 ready queue에 들어가고 다시 wait(mutex)을 호출하고 mutex = 0으로 만들고 임계 구역에 진입한다.
6. 프로세스 P2이 임계구역의 일을 마치고 signal(mutex)을 호출하여 mutex = 1로 만들고 mutex queue에서 block 상태인 프로세스 P3를 깨운다.
7. 프로세스 P3는 ready queue에 들어가고 다시 wait(mutex)을 호출하고 mutex = 0으로 만들고 임계 구역에 진입한다.
```
<뮤텍스 코드>
mutex = 1;

void lock () {
    while (mutex == 1) {
    	  // 다른 프로세스/스레드가 lcok을 잡고있는 상태이므로 mutex값이 0이 될 때까지 대기
    }
    // mutex값이 0인 경우 즉, 아무도 lock을 잡고 있지 않으므로 임계 구역 진입 가능 상태
    // mutex값을 1로 바꾼다(lock을 잡음)
    mutex = 1;
}

void unlock() {
    // 임계 구역에서 나온 프로세스는 다른 프로세스가 접근할 수 있도록 락을 해제한다.
    mutex = 0;
}
```    
---
### 세마포어의 잘못된 사용 : 세마포어를 잘못 사용하면 임계구역이 보호받지 못다는 경우가 있다.
![세마포어의 잘못된 사용](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/30ed1668-6b50-4dcc-8283-8092af566ff4)
1. 프로세스가 세마포어를 사용하지 않고 바로 임계구역에 들어간 경우 -> 상호 배제가 보장되지 않음
2. P()를 두번 사용해 wake_up 신호(임계 구역 진입 가능 신호)가 발생하지 않은 경우 -> 무한 대기 상태 발생
3. P()와 V()를 반대로 사용해 상보 배제가 보장되지 않는 경우 -> 상호 배제가 보장되지 않음
<br>
만약, 공유자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 P(),V()를 사용할 필요 없이 자동으로 처리하도록 하면 된다. 이를 구현한 것이 모니터이다.

---
- 모니터
보호할 자원을 임계 구역으로 숨기고 임계구역에 접근할 수 있는 인터페이스만 제공해 자원을 보호하고 프로세스 간에 동기화를 시키는 알고리즘

### 모니터의 방법
1. 임계구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직접 P(),V()를 사용하지 않고 모니터에 작업을 요청한다.
2. 모니터에 요청받은 작업을 모니터 큐에 삽입한 후 순서대로 공유 자원을 이용하도록 한다.
3. 처리하고 그 결과만 해당 프세스에 알려준다.
-> 즉, 모니터에 진입하기 위한 큐를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공한다.
4. 내부적으로 조건 변수(condition variable)를 이용해 실행 순서 제어한다.

### 모니터의 특징
- 프로그래밍 언어, 혹은 프레임워크 차원에서 제공 ex)Java의 경우 synchronized 키워드, C#의 경우 lock 키워드가 모니터 기능을 제공
- 세마포어와 달리 wait, signal 설정 없이 함수 앞에 synchronized를 붙여주기만 하면 상호배제하여 함수의 작업을 수행
  
### 뮤텍스 vs 모니터
뮤텍스는 다른 포르세스 간 동기화에 사용하고, 모니터는 하나의 프로세스 내에서 다른 스레드 간의 동기화에 사용한다.


---
## 질문
1. 뮤텍스 또는 세마포어에서 busy waiting을 해결하는 방법은??
2. 뮤텍스와 세모포어의 차이점은?
