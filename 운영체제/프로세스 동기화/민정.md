# [OS] 프로세스 동기화

##0. 사전지식
동기화 : 협렵 프로세스 간의 실행 순서를 정해주는 메커니즘

## 1. 프로세스 동기화란 무엇인지 설명해주세요.
프로세스가 공유하는 자원의 일관성을 유지하는 것으로, 프로세스가 통신을 하거나 임계구역 문제를 해결하기 위해 서로 신호를 주고받아 작업 순서를 정하는 것

## 2. 동기화가 필요한 이유가 무엇인지 설명해주세요
Race Condition(경쟁 상태) : 여러 프로세스들이 동시에 공유 자원에 접근하려할 때, 어떤 순서로 데이터에 접근하느냐에 따라 결과 값이 달라질 수 있는 상황
이러한 경쟁 상태에서 프로세스간의 공유 자원 접근 순서를 정해주는 동기화를 통해 데이터 불일치 문제와 데이터 일관성을 유지하기 위해서 필요함.

## 3. 임계구역(Critical Section)이 무엇인지 설명해주세요
임계구역 : 여러 프로세스(또는 스레드)가 자원을 공유하는 상황에서 하나의 프로세스(스레드)만 접근할 수 있도록 제한해둔 영역, 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 코드 영역

### 3-1. 임계구역을 해결하기 위한 조건을 설명해주세요
1. 상호 배제(mutual exclusion) : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없다
2. 한정 대기(bounded waiting) : 어떤 프로세스도 무한 대기하지 않아야 한다. 즉, 특정 프로세스가 임계구역에 진입하지 못하면 안 된다.
3. 진행의 융통성(progress) : 임계구역에 프로세스가 없다면 어떠한 프로세스라도 들어가서 자원을 활용할 수 있다. 즉, 두 프로세스가 자원을 번갈아 쓴다고 가정할 때 한 쪽에서 자원을 안쓰고 있다고해서 다른 한 쪽 프로세스가 자원을 쓰고싶어도 자신의 turn이 아니라고 기다리는 것은 효율적이지 못하다는 것이다.

## 4. 임계구역 해결 방법을 설명해주세요
critical section 문제를 해결하는 단순한 방법은 Lock을 사용하는 것이다.
즉, 한 프로세스가 critical section에 들어간다면 lock을 걸어놓아 다른 프로세스가 들어오지 못하게 한 후, 프로세스가 critical section에서 빠져나오게 되면 lock을 해제하고 동시에 동기화 신호를 보내는 것이다.

### 4-1. 소프트웨어적 해결 방법
- 상호 배제
- 한정 대기
- 진행의 융통성
- 
### 4-2. 하드웨어적인 해결 방법
- Test_and_Set(검사와 지정) 코드 사용 : 메모리에서 데이터를 읽으면서 쓰는 것까지 하나의 명령어로 동시에 수행이 가능하도록 하드웨어적인 지원을 받는 것

![스크린샷 2024-07-04 025807](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/4b00af6c-2f77-4229-9d9c-796fb5cfe798)

lock=true가 작동하기 직전에 timeout이 걸려 ready 상태로 돌아가면 상호 배제에 위배되는 문제가 발생.
이를 해결하기 위해 Test_and_Set(검사와 지정)이라는 코드로 하드웨어 지원을 받아 while(lock == true);문과 lock=true;문을 한꺼번에 실행한다. 검사와 지정 코드를 이용하면 명령어 실행 중간에 타임아웃이 걸려 임계구역을 보호하지 못하는 문제가 발생하지 않음.

하지만 busy waiting(상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다리는 것)을 사용하므로 자원 낭비가 생김

### 4-3. 알고리즘 적용
- 피터슨 알고리즘
![피터슨알고리즘](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/9122be19-4f79-4652-86bc-e70330107f68)
turn이라는 개념을 활용하여, lock을 걸면서 다음의 상대에게 turn을 넘겨주는 것이다.
ex) 프로세스 p2가 잠금을 설정하지 않았거나 잠금을 설정했더라도 turn=1로 바꾸면 프로세스 P1은 임계구역에 진입해 작업을 마친 후 잠금을 해제하고 임계구역을 빠져나옴

- 데커 알고리즘
![데커 알고리즘](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/102593109/0768c92f-8cd6-475d-8ee0-ee2f93c29cf4)
1. 프로세스 P1은 우선 잠금을 건다. (lock1 = true)
2. 프로세스 p2의 잠금이 걸렸는지 확인한다(while(lock2 == true))
3. 만약 프로세스 p2도 잠감을 걸었다면 누가 먼저인지 확인한다.( if(turn == 2)) 만약 프로세스 p1의 차례라면(trun = 1) 임계구역으로 진입한다. 만약 프로세스 p2의 차례라면 (trun =2) 4로 이동한다.
4. 프로세스 p1은 잠금을 풀고(lock1 = false) 프로세스 p2가 작업을 마칠 때까지 기다린다. (while(turn==2)) 프로세스 p2가 작업을 마치면 잠금을 걸고(lock1=true) 임계구역으로 진입한다.

피터슨과 데커 알고리즘은 임계구역 해결의 세가지 조건을 모두 만족하지만 프로세스가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다. 또한, busy wating을 사용하므로 자원 낭비도 일어난다.

3. 세마포어 
