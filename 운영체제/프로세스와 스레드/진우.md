# [OS] 프로세스와 스레드

## 1. 프로세스

> **프로그램 vs 프로세스 vs 프로세서**
프로그램 : 사용자가 원하는 일을 처리할 수 있도록 모아놓은 명령어의 집합(Code + data)
프로세스 : OS가 자원을 할당한 실행중인 프로그램(Code + data +stack + pcb)
프로세서 : CPU
> 

 ****

### 1.1 프로세스의 정의

**프로그램**은 정적이며, HDD,SSD와 같은 저장 장치에 보관되며 **Code, Data**로 이루어져 있다.

**프로세스는** 운영체제가 자원을 할당한 **실행중인 프로그램**이다. **Code, Data + Stack, Heap, PCB**로 이루어져 있다.

OS가 자원을 할당했다는 것은, Code, Data, Stack, Heap, PCB의 영역을 메모리에 할당했다는 것이다.( + cpu 할당)

### 1.2 프로세스의 메모리 구조

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/77064618/dc39fa60-dc3f-4ca3-9f8e-4fe62d3e597c)


각 프로세스는 가상 주소 공간(Virtual Address Space)를 할당 받는다.

> **가상 메모리(Virtual Memory)**는 실제 메모리보다 큰 공간을 사용할 수 있게 하는 기술이며, 이 때 할당하는 공간이 **가상 주소 공간(Virtual Address Space)**이다.
> 

**Code 영역**

사용자가 작성한 프로그램 함수의 코드가 기계어로 변환되어 저장되는 공간

**Data영역**

**전역 변수**, static 변수 등 프로그램이 데이터를 사용하는 공간

**Stack 영역**

호출한 함수의 복귀 주소(Program Counter 값), 데이터**(지역 변수)**등을 임시로 저장하는 공간

함수 호출시 기록하고, 함수 호출이 종료되면 사라진다.

**Heap 영역**

사용자의 필요에 따라 동적으로 할당되는 공간. 

자료구조 Heap과 관련이 없음!

### 1.3 PCB

**PCB(Process Control Block)는 프로세스 제어 블록**으로, 운영체제가 해당 프로세스를 제어하기 위한 다양한 정보가 들어있다.

PCB는 프로그램이 아닌 OS가 사용하는 정보이므로, 메모리의 **커널 영역**에 생성된다.

- Process Identification : 프로세스 .식별 정보
    - PID, 부모PID, ..
- Processor State Information : CPU 관련 정보, Context-switching 과정에서 저장되는 정보
    - 수많은 레지스터 값(PC, PSW…), 스택 포인터
- Process Control Information : 프로세스 관련 정보
    - 스케줄링 정보(우선순위), 메모리 정보, 소유자 정보, 권한, …

> 메모리는 사용자 영역과 커널 영역으로 구분된다.
> 

→ **프로세스는 자원 할당의 단위이다.**

## 2. 스레드

### 2.1. 스레드의 정의

**스레드(Thread)**는 프로세스가 할당받은 자원을 실행하는 실행 단위이다.

하나의 프로세스 내에서도 독립적으로 여러가지 작업이 실행되는 경우가 존재하는데, 이때 작업 단위를 스레드라고 한다.

프로세스는 최소 하나 이상의 스레드를 가진다.

                                                                                                                                

### 2.2. 스레드의 특징

- 스레드는 **실행**의 단위이며, **자원**은 프로세스의 자원을 사용한다.
- **Code, Data, Heap, PCB** 는 공유하여 사용하고 각 스레드는 독자적인 **Stack, TCB**를 가진다.
    - 공유 자원을 이용하여 스레드 간 통신할 수 있다.
- 스레드는 공유 자원을 가지기 때문에 동기화, 데드락 등의 문제가 발생할 수 있다.

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/77064618/f8077c01-da2f-436d-ba82-46a48f1b5336)

## 3. 프로세스 VS 스레드
![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/77064618/c6ba6810-a05d-408d-a3ed-887f72d9febb)


프로세스와 스레드의 장단점에 대해 자세히 나타난 사진이다.

> Q. 프로세스를 만드는 시간이 스레드를 만드는 시간보다 오래 걸리는 이유는?
A. 프로세스 내에서 공유하지 않는 자원인 **스택**만 새로 만들면 되기 때문.
Q. Context Switching 과정에서 프로세스가 더 오래 걸리는 이유는?
A. TCB보다 PCB에 저장되는 정보가 많기 때문.
> 

참고로, 프로세스와 스레드는 5가지의 State가 동일하다.

## 4. 멀티프로세스와 멀티스레드

### 4.1. 멀티 프로세스

하나의 응용 프로그램을 **여러개의 프로세스**로 구성하여, 각 프로세스가 하나의 작업을 하는 것.

**장점**

- 각 프로세스는 독립된 메모리 공간을 가지고, 서로 영향을 주지 않으므로 안정성이 높다.

**단점**

- 다만 컨텍스트 스위칭 등 메모리를 사용하는 비용이 크다.

### 4.2. 멀티스레드

하나의 응용 프로그램을 **여러개의 스레드**로 구성하여 실행하는 방식.

**장점**

- 각 스레드는 독립적으로 실행되지만, 메모리 공간을 공유한다.
- 컨텍스트 스위칭, 공유메모리 등 메모리 관리에 드는 비용이 적다.
- 프로세스간 통신(IPC)보다 스레드 간의 통신이 비용이 적게 든다.

**단점**

- 공유 자원을 사용하므로 동기화, 경쟁, 등의 문제가 발생한다.

![image](https://github.com/java-two-people-get-in/Dododok-CS-study/assets/77064618/d05bf85b-e56b-46e1-a0ec-6e6a30611900)

### 4.3. 멀티스레드를 구현하는 방식

1. User-level Thread
    
    커널레벨에서 멀티스레딩을 지원하지 않는 경우, 유저가 직접 Thread 라이브러리를 사용하여 스레딩을 구현함.
    
2. Kernel-level Thread
    
    커널에서 멀티스레딩을 지원하는 경우.
    
3. Conbined-Approaches for Thread
    
    커널에서 멀티스레딩을 지원하지만, 유저레벨에서 스레딩을 사용하는 경우


Q. 프로그램 내에서 지역 변수는 공유되는 자원이다.
