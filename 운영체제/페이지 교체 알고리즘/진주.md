# 페이지 교체 알고리즘

## 페이지 교체 알고리즘이란?

- 페이징 기법으로 메모리를 관리하는 **운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(페이지 부재)** 어떤 페이지 프레임을 선택하여 교체할 것인지 결정하는 방법을 **페이지 교체 알고리즘**이라고 한다.

<br>

## **페이지 교체 알고리즘의 종류**

1. **OPT** - Optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
2. **FIFO** - First In First Out : 가장 먼저 들어온 페이지를 교체
3. **LRU** - Least ***Recently*** Used : 가장 오랫동안 사용되지 않은 페이지 교체
4. **LFU** - Least ***Frequently*** Used : 참조 횟수가 가장 작은 페이지 교체
5. **MFU** - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체
6. **NUR** - Not Used Recently : 최근에 사용하지 않은 페이지 교체

<br>

### **OPT(Optimal) - 앞으로 가장 오랫동안 사용되지 않을 페이지 교체**

→ 현 시점에서 **앞으로 가장 오랫동안 참조되지 않을** 페이지 즉, 미래에 참조될 때까지 시간이 가장 긴 페이지를 선택하여 교체하는 기법

- 페이지의 부재 최소화
- 프로세스들이 앞으로 어떤 페이지들을 참조할지 미리 알 수는 없기에 현실적으로 구현 불가능
- 다른 기법들과의 성능 평가를 위해 사용

 

![image](https://github.com/user-attachments/assets/8ef56de8-e948-47a2-9fd5-2999d5077d95)

<br>

### **FIFO(First in First out) - 가장 먼저 들어온 페이지를 교체**

→ **적재**된 지 **가장 오래된** 페이지를 교체하는 기법

- 적재된 시간이나 순서를 알아야 함
- 1) 시간 기록 (Time Stamping) 방법
    - 각 페이지가 적재될 때의 시간을 기록한 후, 교체 시 이 시간이 가장 오래된 페이지를 선택
        - 시간 기록을 위한 추가의 기억장소, 가장 오래된 페이지를 찾는데에 걸리는 오버헤드 문제 등
- 2) 큐
    - 큐에서의 상대적인 위치가 적재된 순서를 나타냄. 교체 대상은 항상 큐의 헤드 포인터
        - 교체 대상을 바로 알수 있음
        - 큐 내에서 페이지들이 적정 위치에 있게 자리 잡아주는데에 걸리는 오버헤드

![image](https://github.com/user-attachments/assets/fafd95bf-6e2d-4ace-ab8b-d13f87fc9a79)

<br>


### **LRU(Least *Recently* Used) - 가장 오랫동안 사용하지 않은 페이지를 교체**

→ **참조**된 지가 **가장 오래된** 페이지를 교체하는 기법

[가정] 가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것이다.

- 참조된 시간이나 순서를 알아야 함
- 1) 시간 기록 (Time Stamping) 방법
    - 각 페이지들이 적재될 때의 시간을 기록한 후, 이 페이지가 메모리에 있는 동안 참조될 때마다 가장 최근의 참조 시간으로 갱신
        - FIFO와 마찬가지로 오버헤드 발생
- 2) LRU 스택 (Stack)
    - 스택의 가장 밑에 있는 페이지가 교체 되상이 되도록 상대적인 참조순서를 나타냄

**⇒ 대부분의 시스템에서는 LRU 또는 LRU를 변형시킨 기법이 사용되고 있다.**
(*교체 정책은 어차피 일정부분 오버헤드를 가질 수밖에 없고, 이를 최소화하면서 부재 빈도는 최적에 근접하는 정책을 구현하는 것이 올바른 선택이 되기 때문)

<br>

• LRU를 스택으로 구현한 예


```
✅ 최적보다는 못하지만, FIFO보다는 나음을 확인 가능
```

![image](https://github.com/user-attachments/assets/a3b5763a-541d-4046-a425-6e21ec2d8507)

<br>


### **LFU(Least *Frequently* Used) & MFU(Most Frequently used)**

→  페이지의 **참조 횟수**로 페이지를 교체하는 기법

<br>


### **- LFU(Least *Frequently* Used) - 참조 횟수가 가장 낮은 페이지를 교체**

→  페이지의 **참조 횟수**가 가장 낮은 페이지를 교체하는 기법

[가정] 많이 참조될 페이지는 앞으로도 참조될 확률이 높을 것이다.

- LRU는 직전 참조된 시점만을 반영하지만, 
LFU는 참조횟수를 통해 장기적 시간규모에서의 참조성향 고려할 수 있음
- [단점]
    - 가장 최근에 불러온 페이지가 교체될 수 있음
    - 구현 더 복잡
    - 막대한 오버헤드
- LFU, MFU 모두 편향된 시각에 근거함으로써 실제로 구현되는 경우는 매우 드물다.

<br>


### **- MFU(Most Frequently used) - 참조 횟수가 가장 많은 페이지 교체**

→  페이지의 **참조 횟수**가 가장 높은 페이지를 교체하는 기법

- [가정] 가장 많이 사용된 페이지가 앞으로는 사용되지 않을 것이다.
(= 이미 충분히 참조가 이루어졌기 때문에 더이상 참조되지 않을 것임!)
- LFU, MFU 모두 편향된 시각에 근거함으로써 실제로 구현되는 경우는 매우 드물다.

<br>


### **NUR = NRU(Not Used Recently, Not Recently Used), 클럭 알고리즘**

→ 최근에 사용하지 않은 페이지를 교체

- FIFO의 변형 또는 LRU에 근접하는 기법
- 적재된 후 한번이라도 더 참조된 페이지를 바로 교체시키지 않고 한 번 더 메모리에 머무를 수 있는 기회를 준다.
- **참조비트(Reference Bit)**
    - 0: 바로 교체
    - 1 (= 적재된 후 한 번 이상 참조된 경우)
    : 이 비트를 0으로 만들면서 큐의 맨 뒤로 보냄으로써 메모리에 머무를 기회를 한번 더 줌

---

- **변형 비트(Modified Bit)**: 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때 1
    - 교체가 될 경우 변경된 내용으로 디스크에 기록을 해 주어야 하는 부담이 있으므로, 가급적 교체를 미루어 디스크에 대한 쓰기 작업을 줄이려는 의도
- *우선순위: 참조비트 > 변형비트*

<br>


• 클럭 알고리즘 예

![image](https://github.com/user-attachments/assets/09845e5b-c1a8-4266-b112-9897843d4a7c)

• NUR 예

![image](https://github.com/user-attachments/assets/0a35149c-e07a-461e-bbf9-c30cbd0d5ef1)
