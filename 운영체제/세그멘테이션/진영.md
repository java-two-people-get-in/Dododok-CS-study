# 메모리 오버레이(memory overlay)
> 실제 메모리보다 프로그램의 크기가 더 클때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져온다. 이러한 기법을 **메모리 오버레이(memory overlay)** 라고 한다. **'overlay'** 란 프로그램을 겹겹이 쌓아놓고 실행하는 것을 말한다.

메모리 오버레이의 경우 프로그램을 몇개의 모듈로 나누고 필요할 때마다 모듈을 메모리에 가져와 사용한다. 전체 프로그램을 메모리에 올려놓고 실행하기에는 메모리의 크기가 작기 때문에 실행하는 데 필요한 중요한 모듈만 올려놓고 나머지는 필요할 때 마다 메모리에 가져와 사용하게 된다.

![](https://velog.velcdn.com/images/ozziny/post/c88cfdbf-5526-4731-a4c6-a9fd7513d2c6/image.png)

새로운 모듈을 실행할 메모리가 부족할 때 이전 모듈을 swap area로 옮기고 교체


**메모리 오버레이**에서 어떤 모듈을 가져오거나 내보낼지는 CPU 레지스터 중 하나인 **프로그램 카운터(PC)가 결정**한다. PC는 앞으로 실행할 명령어의 위치를 가리키는 레지스터로 해당 모듈이 메모리에 없으면 메모리 관리자에게 요청하여 메모리로 가져오게 한다.

메모리 오버레이는 다음과 같은 중요한 의미가 있다.

- 한정된 메모리에서 메모리보다 큰 프로그램의 실행이 가능하다. 이는 뒤에 나올 가상 메모리 시스템의 기본이 되는 개념이다.

- 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행이 가능하다. 프로그램은 개념적으로 한 덩어리이지만 일부분만 가지고도 실행할 수 있다. 이는 메모리를 여러 조각으로 나누어 여러 프로세스에 할당할 수 있다는 의미다.

# 스왑(swap)
swap 영역은 별도의 정치가 따로 있는 것은 아님.
swap 영역은 하드디스크에 있음. (EC2에서 swap memory거는게 이런거)

그러나, 하드디스크 같은 저장장치는 저장장치 관리자가 관리하지만, 스왑 영역은 메모리 관리자가 관리한다. 스왑 영역은 메모리에서 쫒겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리하게 된다.

이렇게, 메모리에서 모듈이 스왑 영역으로 가는 것을 **스왑아웃(swap out)**, 반대로 스왑영역에서 메모리로 가는 것을 **스왑인(swap in)**이라고 한다.

메모리 오버레이에서 메모리보다 큰 프로그램을 실행할 때 프로그램을 메모리보다 작은 크기의 모듈로 나누어서 사용한다고 했다. 여기에 스왑을 이용하면 스왑 영역의 크기가 메모리의 크기로 인식된다. 다시 말해 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용할 수 있다. 

(스왑 영역을 설정할 경우 동일한 크기의 기존 메모리만 사용할 때 보다 **속도는 느리지만** 더 큰 메모리 영역을 통해 보다 큰 크기의 프로그램을 실행할 수 있게 된다!)

# 메모리 분할 방식
> 메모리를 어떤 크기로 나눌 것인가는 **메모리 배치 정책**에 해당된다. 메모리에 여러 개의 프로세스를 배치하는 방법은 크게 **가변 분할 방식(variable size partitioning)** ,**고정 분할 방식(fixed size programming)**으로 나뉜다.

- **가변 분할 방식** : 프로세스의 크기에 맞게 메모리가 분할되므로 메모리의 영역이 각각 다르다. 한 프로세스가 연속된 공간에 배치되기 때문에 **연속 메모리 할당**이라고 한다.
- **고정 분할 방식** : 프로세스의 크기에 상관없이 메모리가 같은 크기로 나뉘며, 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치된다. 한 프로세스가 분산되어 배치되기 때문에 **비연속 메모리 할당**이라고 한다.

![](https://velog.velcdn.com/images/ozziny/post/a8c2d769-6aff-4ba8-b407-1b3e95ea831f/image.png)

왼쪽은 가변 분할 방식이기 때문에 각각의 프로세스들이 프로그램의 크기에 따라 가지각색의 메모리 크기를 가지고 있다. 오른쪽은 고정 분할 방식이기 때문에 프로세스들이 고정된 크기인 20kb에 맞게 잘라져 보관된다.

## 메모리 분할 방식 장단점

**가변 분할 방식의 장점**: 가변 분할 방식에서는 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치한다.

**가변 분할 방식의 단점**: 가변 분할 방식은 메모리 관리가 복잡하다. 위의 예에서 프로세스 B, 프로세스 D가 작업을 마쳤다고 하자, 그러면 메모리가 14kb, 27kb가 남는다. 이 때 27kb가 넘는 프로세스가 메모리에 올라오려고 한다면 어떻게 될까?? 빈 공간이 떨어져 있기 때문에 올라올 수가 없다. 27kb가 넘는 프로세스를 실행하려면 비어 있는 공간을 하나로 합쳐야 하며, 이 과정에서 프로세스 C의 자리도 옮겨야 한다. 이처럼 가변 분할 방식은 메모리 통합 등의 부가적인 작업이 필요하므로 메모리 관리가 복잡하다.

**고정 분할 방식의 장점**: 고정 분할 방식에서는 메모리를 일정한 크기로 나누어 관리하기 때문에 메모리 관리가 수월하다. 가변 분할 방식의 메모리 통합 같은 부가적인 작업을 할 필요가 없다.

**고정 분할 방식의 단점**: 고정 분할 방식에서는 쓸모없는 공간으로 인해 메모리 낭비가 발생할 수 있다. 즉 일정하게 나누어진 공간보다 작은 프로세스가 올라올 경우 메모리 낭비가 발생한다. 위에서 언급했던 대로, 프로세스 B의 크기가 14kb인데, 20kb메모리 공간을 할당해주었다. 이 공간은 비어있지만 다른 프로세스를 배치할 수 없으므로 낭비가 된다.

# 세그멘테이션
위에서 말한 가변 분할 방식을 **세그멘테이션 기법**이라고도 한다.

## 외부 단편화
**단편화(fragmentation)** 또는 **조각화**는 메모리에 프로세스를 배치할 수 없는 빈 영역, 즉 조각들을 말한다.

![](https://velog.velcdn.com/images/ozziny/post/5eab3e35-3433-461c-bb27-ec7cd9a676db/image.png)

위의 그림은 가변 분할 방식으로 메모리를 할당했을 때의 방식을 보여준다. 여기서 프로세스 K는 메모리에 들어가길 기다리고 있다. 이 때 프로세스 B, 프로세스 D가 작동을 중지하고 메모리에서 쫒겨난다고 하자.

![](https://velog.velcdn.com/images/ozziny/post/b697f999-bc53-42f4-92bd-551508a0db92/image.png)

메모리에서는 **14+27 = 41kb**이라는 추가 공간이 생겼지만 프로세스 K가 33kb의 크기를 가졌음에도 불구하고 할당될 수 없다. 이는 가변 분할 방식은 연속적으로 프로세스를 메모리에 배치해야하기 때문에 프로세스 K를 넣지 못한다. 이러한 작은 빈 공간을 **외부 단편화(external fragmentation)**라고 한다. 프로세스 밖에서 조각이 발생하기 때문에 이렇게 불린다.

가변 분할 방식에서는 외부 단편화로 인한 문제를 해결하기 위해 **메모리 배치 방식** 이나 **조각 모음**을 사용한다. 

## 메모리 배치 방식
가변 분할 방식의 외부 단편화 문제를 해결하기 위해 대표적인 메모리 배치 방식으로는 **최초 배치(first fir)**, **최적 배치(best fit)**, **최악 배치(worst fit)** 이 외에도 **버디 시스템(buddy system)**이 있다.

- **최초 배치**: 최초 배치(first fit)은 단편화를 고려하지 않는 것으로, 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫 번째로 발견한 공간에 프로세스를 배치하는 방법이다.

![](https://velog.velcdn.com/images/ozziny/post/c1ade2bd-6f3e-4729-b099-ea75e8534498/image.png)

위의 상황에서 프로세스 K는 가장 먼저 확보된 공간에 넣어 아래와 같이 배치된다.

![](https://velog.velcdn.com/images/ozziny/post/5514801c-f3ad-4eea-861d-1b85a6edd3fe/image.png)


- **최적 배치**: 최적 배치는 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법이다.

![](https://velog.velcdn.com/images/ozziny/post/0c1c20f4-f690-4dfb-9659-67e5086f8860/image.png)

위의 상황에서 들어갈 수 있는 가장 작은 공간인 33kb의 공간에 아래와 같이 배치된다.

![](https://velog.velcdn.com/images/ozziny/post/10def542-7110-49be-9000-daa95fe5bd5a/image.png)

- **최악 배치**:최적 배치와 정반대로 최악 배치는 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방식이다. 위의 예제에서 35kb에 프로세스 k를 배치하는 것이다.

## 압축
단편화가 발생하면 이미 배치된 프로세스를 옆으로 옮겨 빈 공간들을 하나의 큰 덩어리로 만들어야 하는데 이것이 압축이며 **조각 모음**이라고도 한다.

![](https://velog.velcdn.com/images/ozziny/post/dccae678-4530-4452-88cf-9a113a0c89ff/image.png)

위의 사진이 바로 압축으로 다음의 과정을 거친다.

1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다.
2. 프로세스를 적당한 위치로 이동한다. 프로세스가 원래의 위치에서 이동하기 때문에 프로세스의 상대 주소값을 바꾼다.
3. 이러한 작업을 다 마친 후 프로세스를 다시 시작한다.

압축을 하려면 프로세스를 중지시키고, 이동하고, 주소를 바꾸고, 다시 시작하는 작업을 해야하기 때문에 시간이 많이 걸린다. 이처럼 가변 분할 방식은 외부 단편화로 인해 조각 모음 같은 부가적인 작업이 필요하므로 **메모리 관리가 복잡**하다.

> 참고로 외부 단편화는 하드디스크와 같은 저장장치에서도 발생한다. 하드디스크에는 동영상과 같은 큰 파일도 저장되고 문서와 같은 작은 파일도 저장된다. 빈 하드디스크에 데이터를 채주면 데이터가 차곡차곡 쌓이다가 데이터의 삭제와 저장을 반복하면 데이터가 여러 공간에 나뉘어 저장된다. 이러한 현상은 시간이 흐를수록 더욱 심해지고 결국 하드디스크의 입출력 속도를 떨어뜨려 컴퓨터의 성능을 저하시키는 원인이 된다. 따라서 하드디스크와 같은 저장장치도 성능을 유지하려면 추가적으로 조각 모음을 실행해야한다.

## 참고자료
[OS는 할껀데 핵심만 합니다. 13편 가변 분할 메모리와 고정 분할 메모리, 단편화](https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-13%ED%8E%B8-%EA%B0%80%EB%B3%80-%EB%B6%84%ED%95%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EA%B3%A0%EC%A0%95-%EB%B6%84%ED%95%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94)
[[OS] 메모리 단편화, 페이징, 세그먼테이션](https://velog.io/@mingsso/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98-5uqe5smj)


